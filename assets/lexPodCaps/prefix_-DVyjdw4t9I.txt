WEBVTT

00:00.000 --> 00:07.320
Can you imagine possible features that Python 4.0 might have that

00:07.320 --> 00:14.320
would necessitate the creation of the new 4.0, given the amount of

00:15.120 --> 00:20.320
pain and joy, suffering and triumph that was involved in the move

00:20.320 --> 00:22.880
between version two and version three.

00:25.320 --> 00:28.200
The following is a conversation with Guido Van Rossum, his

00:28.200 --> 00:29.760
second time on this podcast.

00:29.920 --> 00:33.760
He is the creator of the Python programming language and is

00:33.760 --> 00:38.520
Python's Emeritus BDFL, Benevolent Dictator for Life.

00:39.040 --> 00:40.960
This is the Lex Friedman podcast.

00:41.080 --> 00:44.040
To support it, please check out our sponsors in the description.

00:44.360 --> 00:47.520
And now, dear friends, here's Guido Van Rossum.

00:48.600 --> 00:51.840
Python 3.11 is coming out very soon.

00:52.480 --> 00:57.320
In it, see Python claim to be 10 to 60% faster.

00:57.720 --> 00:58.720
How'd you pull that off?

00:59.320 --> 01:00.320
And what's CPython?

01:00.520 --> 01:04.600
CPython is the last Python implementation standing, also the

01:04.600 --> 01:06.200
first one that was ever created.

01:06.320 --> 01:10.080
The original Python implementation that I started over 30 years ago.

01:10.240 --> 01:13.400
So what does it mean that Python, the programming language, is

01:13.440 --> 01:16.720
implemented in another programming language called C?

01:16.880 --> 01:19.240
What kind of audience do you have in mind here?

01:19.720 --> 01:21.240
People who know programming?

01:21.280 --> 01:24.480
No, there's somebody on a boat that's into fishing and have never

01:24.480 --> 01:27.920
heard about programming, but also some world-class programmers.

01:27.920 --> 01:29.160
So you're going to have to speak to both.

01:29.360 --> 01:31.000
Imagine a boat with two people.

01:31.320 --> 01:34.360
One of them has not heard about programming, is really into fishing.

01:34.800 --> 01:39.640
And the other one is like an incredible Silicon Valley programmer

01:39.640 --> 01:41.120
that's programmed in everything.

01:41.440 --> 01:46.720
C, C++, Python, Rust, Java, and knows the entire history of programming

01:46.720 --> 01:48.360
languages, so you're going to have to speak to both.

01:49.120 --> 01:51.360
I imagine that boat in the middle of the ocean.

01:51.800 --> 01:55.000
I'm going to please the guy who knows how to fish first.

01:55.080 --> 01:55.640
Yes, please.

01:57.280 --> 01:59.720
He seems like the most useful in the middle of the ocean.

01:59.800 --> 02:01.520
You got to make him happy.

02:01.520 --> 02:03.000
I'm sure he has a cell phone.

02:03.040 --> 02:08.040
So he's probably very suspicious about what goes on in that cell phone, but

02:08.040 --> 02:13.360
he must have heard that inside a cell phone is a tiny computer and a programming

02:13.360 --> 02:17.040
language is computer code that tells the computer what to do.

02:17.360 --> 02:19.840
It's a very low level language.

02:20.400 --> 02:26.040
It's zeros and ones, and then there's assembly and then, oh, yeah, we don't

02:26.040 --> 02:30.080
talk about these really low levels because those just confuse people.

02:30.120 --> 02:34.240
I mean, when we're talking about human language, we're not usually talking

02:34.240 --> 02:37.400
about vocal tracts and how you position your tongue.

02:37.400 --> 02:42.400
I was talking yesterday about how when you have a Chinese person and they

02:42.400 --> 02:46.640
speak English, this is a bit of a stereotype.

02:46.680 --> 02:51.480
They often don't know or they can't seem to make the difference well

02:51.480 --> 02:53.200
between an L and an R.

02:54.120 --> 03:00.160
And I have a theory about that and I've never checked this with linguists that

03:00.200 --> 03:04.400
it probably has to do with the fact that in Chinese, there is not really a

03:04.400 --> 03:10.400
difference and it could be that there are regional variations in how native

03:10.400 --> 03:17.840
Chinese speakers pronounce that one sound that sounds like L to some of them,

03:17.840 --> 03:19.000
like R to others.

03:19.280 --> 03:24.240
So it's both the sounds you produce with your mouth throughout the history of

03:24.240 --> 03:27.160
your life and what you're used to listening to.

03:27.160 --> 03:28.280
I mean, every language has that.

03:28.280 --> 03:34.960
Russian has, the Slavic languages have sounds like the letters, like

03:35.360 --> 03:38.680
Americans or English speakers don't seem to know the sound.

03:40.960 --> 03:43.160
They seem uncomfortable with that sound.

03:43.600 --> 03:44.360
Yeah.

03:44.520 --> 03:45.400
So, oh yes.

03:45.400 --> 03:45.680
Okay.

03:45.680 --> 03:49.560
So we're not, we're not going to the shapes of tongues and the

03:49.560 --> 03:50.960
sounds that the mouth can make.

03:50.960 --> 03:51.360
Fine.

03:51.360 --> 03:55.800
And similarly, we're not going into the ones and zeros or machine language.

03:56.240 --> 04:01.480
I would say a programming language is a list of instructions, like a cookbook

04:01.480 --> 04:08.000
recipe that sort of tells you how to do a certain thing, like make a sandwich.

04:08.000 --> 04:16.040
Well, acquire a loaf of bread, cut it in slices, take two slices, put mustard on

04:16.040 --> 04:22.320
one, put the jelly on the other or something, then add the meat, then add the cheese.

04:23.440 --> 04:29.040
I've heard that science teachers can actually do great stuff with recipes

04:29.040 --> 04:34.080
like that and trying to interpret their students instructions incorrectly until

04:34.080 --> 04:38.240
the students are completely unambiguous about it with language.

04:38.240 --> 04:42.320
See, that's the difference between natural languages and programming languages.

04:42.880 --> 04:48.720
I think ambiguity is a feature, not a bug in human spoken languages.

04:49.080 --> 04:53.360
Like, uh, that's the dance of communication between humans.

04:54.280 --> 04:57.960
Well, for lawyers, ambiguity certainly is a feature.

04:58.960 --> 05:06.040
Uh, for plenty of other cases, uh, the ambiguity is, is not much of a feature,

05:06.040 --> 05:07.800
but we work around it, of course.

05:08.200 --> 05:10.520
Well, what's more important is context.

05:11.160 --> 05:15.920
So with context, the precision of the statement becomes more and more concrete.

05:16.040 --> 05:16.400
Right.

05:16.760 --> 05:22.560
But you know, when you say, I love you to a person that matters a lot to you, the

05:22.560 --> 05:26.960
person doesn't try to compile that statement and return an error saying, please define

05:26.960 --> 05:29.120
love right now.

05:29.160 --> 05:34.240
But I imagine that my wife and my son, uh, interpreted very differently.

05:35.480 --> 05:35.920
Yes.

05:35.960 --> 05:40.640
Even though it's the same three words, but imprecisely still for sure.

05:41.880 --> 05:44.520
Lawyers never a lot of follow up questions for you.

05:44.560 --> 05:48.160
Nevertheless, the context is already different, different in that case.

05:48.240 --> 05:48.520
Yes.

05:48.520 --> 05:49.000
Fair enough.

05:49.000 --> 05:56.400
So that's, that's a programming language is a ability to unambiguously state a

05:56.400 --> 05:56.960
recipe.

05:58.080 --> 05:59.360
Actually, let's go back.

05:59.800 --> 06:00.840
Let's go to Pepe.

06:01.360 --> 06:07.080
You go through and Pepe, the style guy for Python code, some ideas of what this

06:07.080 --> 06:11.000
language should look like, feel like, read like.

06:11.400 --> 06:14.280
And the big idea there is that code readability counts.

06:14.680 --> 06:15.520
What does that mean to you?

06:16.040 --> 06:17.040
And how do we achieve it?

06:17.320 --> 06:19.000
So this recipe should be readable.

06:19.040 --> 06:25.000
That's a thing between programmers because, uh, on the one hand, we always

06:25.000 --> 06:31.160
explain the concept of programming language as computers need instructions

06:31.200 --> 06:35.440
and computers are very dumb and they need very precise instructions because they

06:35.440 --> 06:39.480
don't have much context in, in, in fact, they have lots of context, but their,

06:39.680 --> 06:41.280
their context is very different.

06:42.280 --> 06:48.800
But what we've seen emerge during the development of software, starting in the,

06:48.880 --> 06:56.080
probably in the late forties is that software is a very social activity.

06:56.560 --> 07:01.040
A software developer is not a mad scientist who sits alone in his lab,

07:01.040 --> 07:02.480
writing brilliant code.

07:03.560 --> 07:07.520
Uh, software is developed by teams of people.

07:08.400 --> 07:13.440
Uh, even the mad scientist sitting alone in his lab can type fast enough to produce

07:13.480 --> 07:18.720
enough code so that by the time he's done with his coding, he still remembers

07:18.720 --> 07:21.600
what the first few lines he wrote mean.

07:22.080 --> 07:28.360
So even the mad scientist coding alone in his lab would, would be sort of wise

07:28.360 --> 07:36.440
to adopt conventions on how to format the instructions that he gives to the

07:36.440 --> 07:41.720
computer so that the thing is there is a difference between a cookbook recipe

07:41.720 --> 07:43.440
and a computer program.

07:44.320 --> 07:50.000
The cookbook recipe, the author of the cookbook writes it once and then it's

07:50.000 --> 07:56.000
printed in a hundred thousand copies and then lots of people in their kitchens try

07:56.000 --> 08:03.160
to recreate that recipe, that, that, that particular pie or dish from the recipe.

08:03.800 --> 08:12.200
And so there, the, the goal of the cookbook author is to make it clear to

08:12.200 --> 08:18.600
the human reader of the recipe, the human amateur chef in most cases.

08:19.640 --> 08:26.080
When you're writing a computer program, you have two audiences at once.

08:27.080 --> 08:36.200
It needs to tell the computer what to do, but it also is useful if that

08:36.200 --> 08:42.080
program is readable by other programmers because computer software, unlike the

08:42.080 --> 08:50.800
typical recipe for a cherry pie is so complex that you don't get all of it

08:50.960 --> 08:56.960
right at once, you end up with the activity of debugging and you end up with

08:56.960 --> 09:04.560
the activity of, so debugging is trying to figure out why your code doesn't run

09:04.560 --> 09:05.960
the way you thought it should run.

09:06.560 --> 09:10.960
That means broadly, it could be stupid little errors or it could be big logical

09:10.960 --> 09:13.720
errors, it could be anything spiritual.

09:14.040 --> 09:14.320
Yeah.

09:14.520 --> 09:21.360
It could be anything from a typo to a wrong choice of algorithm to building

09:21.360 --> 09:25.480
something that does what you tell it to do, but that's not useful.

09:26.440 --> 09:26.800
Yeah.

09:26.880 --> 09:32.400
It seems to work really well 99% of the time, but does weird things

09:32.400 --> 09:34.560
1% of the time on some edge cases.

09:35.120 --> 09:37.360
That's pretty much all software nowadays.

09:37.520 --> 09:38.800
All good software, right?

09:38.840 --> 09:43.680
Well, yeah, for, for bad software that 99 goes down a lot.

09:43.920 --> 09:46.600
So, but it's not just about the complexity of the program.

09:46.600 --> 09:52.520
It's like you said, it is a social endeavor in that you're constantly

09:52.520 --> 09:57.520
improving that recipe for the cherry pie, but you're sort of, you're in a group

09:57.520 --> 10:04.160
of people improving that recipe or the mad scientist is improving the recipe

10:04.160 --> 10:10.920
that he created a year ago and making it better or adding, adding something.

10:10.960 --> 10:14.360
He decides that he wants a, I don't know, he wants some

10:14.360 --> 10:16.760
decoration on his pie or icing or.

10:17.840 --> 10:22.080
So there's broad philosophical things and there's specific advice on style.

10:22.640 --> 10:25.400
So first of all, the thing that people first experience when they look at

10:25.400 --> 10:32.840
Python, there is a, it is very readable, but there's also like a spatial structure

10:32.840 --> 10:39.200
to it, can you explain the indentation style of Python and what is the magic to it?

10:39.400 --> 10:43.640
Spaces are important for readability of any kind of text.

10:44.360 --> 10:53.200
If you take a cookbook recipe and you remove all the sort of, all the bullets

10:53.280 --> 10:58.480
and other markup, and you just crunch all the text together, maybe you leave

10:58.480 --> 11:04.160
the spaces between the words, but that's all you leave when you're in the kitchen

11:04.520 --> 11:08.600
trying to figure out, Oh, what are the ingredients and what are the steps?

11:09.440 --> 11:12.200
And where does this step end and the next step begin?

11:12.760 --> 11:16.440
You're going to have a hard time if it's, if it's just one solid block of text.

11:17.560 --> 11:22.120
On the other hand, but what a typical cookbook does, if the paper is not too

11:22.120 --> 11:28.080
expensive, each recipe starts on its own page, maybe there's a picture next to it.

11:28.600 --> 11:31.000
The list of ingredients comes first.

11:31.800 --> 11:34.320
Uh, there's a standard notation.

11:34.640 --> 11:40.560
Uh, there's, there's shortcuts so that you don't have to sort of write two

11:40.560 --> 11:44.640
sentences on how you have to cut the onion, because there are only three ways

11:44.640 --> 11:49.000
that people ever cut onions in a kitchen, small, medium, and in slices

11:49.480 --> 11:50.360
or something like that.

11:51.480 --> 11:51.840
Right.

11:52.000 --> 11:55.240
None of my examples make any sense to real cooks, of course, but

11:58.000 --> 12:00.400
we're talking to programmers with the metaphor of cooking.

12:00.440 --> 12:00.880
I love it.

12:01.240 --> 12:05.680
Um, but there is a strictness to the spacing that Python defines.

12:06.040 --> 12:11.320
So there's some looser things, some stricter things, but the four spaces

12:11.320 --> 12:14.760
for the, uh, for the indentation is really interesting.

12:14.840 --> 12:19.680
It, it really, um, it really defines what the language looks and feels like.

12:19.800 --> 12:25.320
Because indentation sort of taking a block of text and then having inside

12:25.320 --> 12:30.360
that block of text, a smaller block of text that is indented further.

12:30.960 --> 12:38.000
As sort of a group, it's, it's, it's like, you have a bulleted list in a

12:38.000 --> 12:43.360
complex business document and inside some of the bullets are other bulleted lists.

12:43.680 --> 12:45.240
You will indent those too.

12:46.200 --> 12:51.280
If each bulleted list is indented several inches, then at two levels

12:51.280 --> 12:56.080
deep, there's no, no space left on the page to put any of the words of the text.

12:56.400 --> 12:58.120
So you can't indent too far.

12:58.120 --> 13:02.720
On the other hand, if you don't indent at all, uh, you can tell whether

13:02.720 --> 13:06.840
something is a top level bullet or a second level bullet or a third level bullet.

13:06.840 --> 13:16.160
So you have to have some compromise and, uh, based on ancient conventions and

13:16.240 --> 13:22.080
sort of the typical width of a computer screen in the eighties, uh, and all

13:22.080 --> 13:29.800
sorts of things, sort of, we, we came up with sort of four spaces as a compromise.

13:30.320 --> 13:34.760
I mean, there, there are groups, there are large groups of people who code

13:34.760 --> 13:38.200
with, uh, two spaces per indent level.

13:38.240 --> 13:43.160
Uh, for example, the Google style guide, uh, all the Google Python code.

13:43.160 --> 13:46.160
And I think also all the Google C plus plus code is indented

13:46.160 --> 13:47.920
with only two spaces per block.

13:48.440 --> 13:55.680
If you're not used to that, it's harder to at a glance understand the code

13:55.680 --> 14:00.680
because the, the sort of the high level structure is determined by the indentation.

14:01.120 --> 14:04.440
On the other hand, there, there are other programming languages where the

14:04.440 --> 14:10.160
indentation is, uh, eight spaces or a whole tap stop in, in sort of classic

14:10.160 --> 14:14.600
unix and to me that looks weird because you, you sort of after three indent

14:14.600 --> 14:16.840
levels, you've, you've got no room left.

14:18.000 --> 14:21.680
Well, there is some languages where the indentation is a recommendation.

14:22.560 --> 14:23.800
It's a stylistic one.

14:23.800 --> 14:26.360
The code compiles even without any indentation.

14:27.280 --> 14:31.200
And then Python really indentation is a fundamental part of the language.

14:31.280 --> 14:31.560
Right.

14:32.960 --> 14:34.840
It doesn't have to be four spaces.

14:34.840 --> 14:41.480
So you, you can code Python with two spaces per block or four or six spaces

14:41.480 --> 14:44.400
or 12, if you really want to go wild.

14:44.400 --> 14:51.400
But sort of everything that belongs to the same block needs to be indented

14:51.400 --> 14:56.440
the same way in practice, in most other languages, people recommend doing that.

14:56.480 --> 15:04.760
Anyway, if you look at C or rust or C plus plus all those languages, Java

15:05.240 --> 15:12.160
don't have a requirement of indentation, but except in extreme cases, they're

15:12.160 --> 15:16.600
just as anal about having their code properly indented.

15:17.000 --> 15:24.080
So any IDEs that the syntax highlighting that works with Java or C plus plus,

15:24.080 --> 15:26.720
they will yell at you aggressively.

15:26.720 --> 15:31.080
If you don't do proper indentation, they'd suggest the proper indentation

15:31.080 --> 15:38.240
for you, like, uh, in C you type a few words and then you type a curly brace,

15:38.240 --> 15:43.280
which there is their notion of sort of begin and an indented block.

15:43.720 --> 15:43.920
Yep.

15:44.320 --> 15:48.720
Uh, then you hit return and then it automatically indents four or eight

15:48.720 --> 15:53.480
spaces, depending on, uh, your, your style preferences or how your editor is configured.

15:53.840 --> 15:58.480
Was there a possible universe in which you considered having braces in Python?

15:59.200 --> 15:59.920
Absolutely.

16:00.120 --> 16:00.360
Yeah.

16:00.720 --> 16:04.480
What was the 60, 40, 70, 30 in your head?

16:04.520 --> 16:07.080
Uh, what was the trade off?

16:07.120 --> 16:13.920
For a long time, I was actually convinced that the indentation was just better.

16:15.480 --> 16:22.040
Uh, without context, I would still claim that indentation is better.

16:23.120 --> 16:25.760
Uh, it reduces clutter.

16:25.920 --> 16:30.920
However, as I started to say earlier, context is almost everything.

16:31.800 --> 16:38.160
And in the context of coding, most programmers are familiar with multiple

16:38.160 --> 16:45.160
languages, even if they're only good at one or two and apart from Python and

16:45.160 --> 16:49.400
maybe Fortran, I don't know how that's written these days anymore, but all the

16:49.400 --> 16:56.080
other languages, Java, Rust, C, C plus plus JavaScript, TypeScript, Perl are all

16:56.120 --> 17:01.560
using curly braces, uh, to sort of indicate blocks.

17:02.120 --> 17:04.040
And so Python is the odd one out.

17:04.720 --> 17:06.120
So it's a radical idea.

17:06.600 --> 17:10.880
Do you still as a radical renegade revolutionary, do you still stand

17:10.880 --> 17:15.200
behind this idea of space of, uh, indentation versus braces?

17:15.960 --> 17:18.360
Like what, what can you dig into it a little bit more?

17:19.000 --> 17:22.360
Why you still stand behind indentation?

17:22.640 --> 17:25.640
Because context is not the whole story.

17:25.640 --> 17:29.440
History in a sense provides more context.

17:29.440 --> 17:35.640
So for Python, there's no chance that we can switch.

17:36.640 --> 17:41.040
Python is using curly braces for something else, dictionaries mostly.

17:42.040 --> 17:47.120
We would get in trouble if we wanted to switch, just like you couldn't redefine

17:47.120 --> 17:55.160
C to use indentation, even if you agree that that indentation sort of in a

17:55.160 --> 17:57.360
Greenfield environment would be better.

17:57.960 --> 18:02.080
You can't change that kind of thing in a language.

18:02.800 --> 18:08.160
It's hard enough to reach agreement over over much more minor details.

18:08.160 --> 18:12.560
Maybe, I mean, in the past in Python, we did have a big debate about tabs

18:12.560 --> 18:18.640
versus spaces and for spaces versus fewer or more, and we sort of came up

18:18.640 --> 18:24.760
with a recommended standard and sort of options for people who want to be

18:24.760 --> 18:30.640
different, but yes, I guess, uh, the thought experiment I'd like you to

18:30.640 --> 18:35.800
consider is if you could travel back through time when the, when the

18:35.800 --> 18:41.160
compatibility is not an issue and you started Python all over again, can you

18:41.160 --> 18:45.360
make the case for indentation still?

18:46.120 --> 18:50.920
Well, it frees up a pair of, uh, matched brackets of which there are never

18:50.960 --> 18:54.560
enough in the world, uh, for other purposes.

18:55.120 --> 19:03.360
It really makes the language slightly sort of easier to grasp for people who

19:03.360 --> 19:11.160
don't already know another programming language because the sort of one of the

19:11.160 --> 19:17.480
things, and I mostly got this from my mentors who, uh, taught me programming

19:17.480 --> 19:24.480
language design in the earlier eighties when you're teaching programming for,

19:24.520 --> 19:31.160
for the, the, the total newbie who has not coded before it, not in any other

19:31.160 --> 19:39.880
language, uh, a whole bunch of concepts in programming are very alien or sort

19:39.880 --> 19:46.640
of new and, and maybe very interesting, but also distracting and confusing.

19:46.640 --> 19:48.920
And there are many different things you have to learn.

19:48.920 --> 19:55.800
You have to sort of in a typical 13 week programming course, you have

19:55.800 --> 20:02.600
to, if it's like really learning to program from scratch, you have to

20:02.600 --> 20:06.160
cover algorithms, you have to cover data structures, you have to cover

20:06.520 --> 20:12.840
syntax, you have to cover variables, loops, functions, recursion, classes,

20:13.800 --> 20:16.200
uh, expressions, operators.

20:16.560 --> 20:18.400
There are so many concepts.

20:18.480 --> 20:25.080
If you, you sort of, if you can spend a little less time having to

20:25.080 --> 20:33.840
worry about the syntax, the classic example was often, Oh, the compiler

20:33.840 --> 20:38.680
complains every time I put a semi column in the wrong place, or I

20:38.680 --> 20:44.160
forget to put a semi column, uh, Python doesn't have semi columns in that

20:44.160 --> 20:46.680
sense, so you can't forget them.

20:47.160 --> 20:52.600
And you were also not sort of misled into putting them where they don't

20:52.600 --> 20:56.000
belong because you don't learn about them in the first place.

20:56.920 --> 21:01.520
The flip side of that is forcing the strictness onto the beginning

21:01.520 --> 21:07.400
programmer to teach them that programming is, um, values, attention to

21:07.400 --> 21:08.000
details.

21:08.000 --> 21:10.920
You don't get to just write the way you write an English paper, other

21:10.920 --> 21:13.800
details that they have to pay attention to.

21:13.800 --> 21:18.560
So I think they'll, they'll still get the message about, uh, paying

21:18.560 --> 21:20.960
attention to detail, the interesting design choice.

21:20.960 --> 21:24.840
So I still program quite a bit in PHP and I'm sure there's other

21:24.840 --> 21:29.640
languages like this, but the dollar sign before a variable, that was

21:30.120 --> 21:32.640
always an annoying thing for me.

21:33.080 --> 21:36.920
It didn't quite fit into my understanding of why this is good for

21:36.920 --> 21:37.880
programming language.

21:38.400 --> 21:40.560
I'm not sure if you ever thought about that one.

21:41.600 --> 21:44.240
That is a historical thing.

21:44.320 --> 21:47.680
There is a whole lineage of programming languages.

21:47.720 --> 21:50.080
PHP is one.

21:50.240 --> 21:51.600
Perl was one.

21:52.280 --> 21:58.400
On the Unix shell, uh, is one of the oldest or, or all the different shells.

21:59.440 --> 22:06.400
The dollar was invented for that purpose because the very earliest shells had a

22:06.400 --> 22:10.560
notion of scripting, but they did not have a notion of parameterizing the

22:10.560 --> 22:11.120
scripting.

22:12.040 --> 22:12.320
Right.

22:12.480 --> 22:18.640
And so a script is just a few lines of text where each line of text is a

22:18.640 --> 22:24.920
command that is read by a very primitive command processor that then sort of

22:25.000 --> 22:29.840
takes the first word on the line as the name of a program and passes all the,

22:30.040 --> 22:36.120
all the rest of the line as text into the program for the program to figure

22:36.120 --> 22:38.840
out what to do with as arguments.

22:39.560 --> 22:45.720
And so by the time scripting was slightly more mature than the very first script,

22:46.520 --> 22:53.640
there was a convention that just like the first word on the line is, uh, the

22:53.640 --> 23:01.160
name of the program, the following words, uh, could be names of files, input dot

23:01.160 --> 23:05.160
text, output dot HTML, things like that.

23:06.120 --> 23:11.320
The next thing that happens is, Oh, it would actually be really nice if we

23:11.320 --> 23:15.280
could have variables and especially parameters for scripts.

23:15.400 --> 23:21.360
Parameters are usually what starts this process, but now you have a problem

23:21.360 --> 23:26.600
because you can't just say the parameters are X, Y, and Z.

23:27.440 --> 23:33.400
And so now we call, say, let's say X is the input file and Y is the output file.

23:33.400 --> 23:35.160
And let's forget about Z for now.

23:35.680 --> 23:39.560
I have my program and I write program X, Y.

23:39.600 --> 23:46.240
Well, that already has a meaning because that presumably means X itself is the file.

23:47.360 --> 23:48.400
It's a file name.

23:48.440 --> 23:49.920
It's not a variable name.

23:51.720 --> 23:58.320
Uh, and so the inventors of, of things like the Unix shell and I'm sure job

23:58.360 --> 24:07.400
command language in at IBM before that, uh, had to use something that made it

24:07.400 --> 24:14.560
clear to the script processor here is an X that is not actually the name of a file,

24:14.560 --> 24:20.720
which you just pass through to the, to the program you're running here is an X

24:20.720 --> 24:22.280
that is the name of a variable.

24:23.000 --> 24:29.160
And when you're writing a script processor, you try to keep it as simple

24:29.160 --> 24:36.840
as possible because certainly in the fifties and sixties, uh, the thing that

24:36.840 --> 24:41.360
interprets the script was itself a very, had to be a very small program because it

24:41.360 --> 24:43.800
had to fit in a very small part of memory.

24:44.440 --> 24:48.640
And so saying, Oh, just look at each character.

24:48.680 --> 24:53.600
And if you see a dollar sign, you jump to another section of the code and then you

24:53.600 --> 24:58.280
gobble up characters or say until the next space or something, and you say

24:58.280 --> 24:59.360
that's the variable name.

25:00.480 --> 25:09.640
And so it was, was sort of invented as a clever way to make parsing of things

25:09.640 --> 25:15.800
that contain both contain both variable and fixed parts, very easy in a

25:15.800 --> 25:17.600
very simple script processor.

25:18.080 --> 25:23.760
It also helps even then it also helps the human author and the human

25:23.760 --> 25:32.000
reader of the, the script to quickly see, Oh, 20 lines down in the script.

25:32.040 --> 25:34.040
I see a reference to X, Y, Z.

25:34.080 --> 25:35.640
Oh, it has a dollar in front of it.

25:35.640 --> 25:39.480
So now we know that X, Y, Z must be one of the parameters of the script.

25:39.560 --> 25:40.880
Well, this is fascinating.

25:40.960 --> 25:46.040
Several things to say, which is the leftovers from the simple script

25:46.080 --> 25:51.560
processor languages are now in code bases, like behind Facebook or behind

25:51.560 --> 25:54.760
most of the backend, I think PHP is probably still runs most of the

25:54.760 --> 25:55.960
backend of the internet.

25:56.240 --> 25:56.640
Oh yeah.

25:56.760 --> 25:56.880
Yeah.

25:56.880 --> 25:59.600
I think there's a lot of it in Wikipedia too, for example.

25:59.600 --> 25:59.840
Yeah.

26:00.400 --> 26:02.640
It's funny that those decisions are not funny.

26:02.640 --> 26:06.240
It's fascinating that those decisions permeate through time.

26:07.040 --> 26:09.160
Just like biological systems, right?

26:10.040 --> 26:16.280
I mean that the sort of the inner workings of DNA have been stable for,

26:16.320 --> 26:21.320
well, I don't know how long it was, like 300 million years, half a billion years.

26:22.360 --> 26:27.080
And there, there are all sorts of weird quirks there that don't make a lot of

26:27.080 --> 26:32.760
sense if you were to design a system like self replicating molecules from scratch.

26:33.200 --> 26:36.360
Well, that system has a lot of interesting resilience.

26:36.960 --> 26:43.160
It has redundancy that results like it messes up in interesting ways that

26:43.160 --> 26:47.720
still is resilient when you look at the system level of the organism code

26:47.720 --> 26:51.960
doesn't necessarily have that program, a computer programming code.

26:52.600 --> 26:58.240
You'd be surprised how much resilience modern code has.

26:58.840 --> 27:04.440
I mean, if you, if you look at the number of bugs per line of code, even

27:04.440 --> 27:11.880
in, in very well tested code that in practice works just fine, there are

27:11.880 --> 27:18.840
actually lots of things that don't work fine and there are error correcting or

27:18.840 --> 27:22.080
self correcting mechanisms at many levels.

27:22.520 --> 27:24.440
Including probably the user of the code.

27:24.920 --> 27:29.720
Well, in the end, the user who sort of is told, well, you got to reboot

27:29.800 --> 27:33.080
your, your PC is part of that system.

27:33.640 --> 27:41.240
And a slightly less drastic thing is reload the page, which we all know how

27:41.240 --> 27:43.600
to do without thinking about it.

27:43.600 --> 27:47.880
When something weird happens, you, you try to reload a few times before you

27:47.880 --> 27:49.760
say, oh, there's something really weird.

27:50.000 --> 27:50.280
Okay.

27:50.280 --> 27:53.360
Or try to click the button again, if the first time didn't work.

27:54.520 --> 27:58.520
Well, yeah, that we should all have learned not to do that because that's

27:58.520 --> 28:01.040
probably just going to turn the light back off.

28:01.480 --> 28:02.120
Yeah, true.

28:02.200 --> 28:03.320
So do it three times.

28:03.320 --> 28:04.840
That's the, that's the right lesson.

28:05.200 --> 28:11.680
So, uh, and I wonder how many people actually like the dollar sign.

28:11.880 --> 28:13.800
Like you said, it is documentation.

28:14.120 --> 28:20.880
So to me, it's whatever the opposite of syntactic sugar is syntactic poison to

28:20.880 --> 28:25.240
me, it is such a pain in the ass that I have to type in a dollar sign also

28:25.280 --> 28:26.320
super error prone.

28:27.040 --> 28:28.840
So it's not self-documenting.

28:28.880 --> 28:31.600
It's it's like a bug generating thing.

28:31.960 --> 28:33.320
It is a kind of documentation.

28:33.320 --> 28:37.760
That's the pro and the con is it's a source of a lot of bugs, but actually I

28:37.760 --> 28:42.320
have to ask you, um, this is really interesting idea of bugs per line of

28:42.320 --> 28:47.280
code, if you look at all the computer systems out there from the code that

28:47.280 --> 28:52.520
runs nuclear weapons to the code that runs all the amazing companies that

28:52.520 --> 28:57.400
you've been involved with and not code that runs Twitter and Facebook and

28:57.400 --> 29:03.480
Dropbox and Google and Microsoft windows and so on, and we like laid out,

29:05.360 --> 29:10.640
wouldn't that be a cool like table bugs per line of code and what would that

29:10.640 --> 29:12.840
let's, let's put like actual companies aside.

29:13.480 --> 29:16.760
Do you think we'd be surprised by the number we see there for all these

29:16.760 --> 29:21.920
companies that depends on whether you've ever read about.

29:22.320 --> 29:25.520
Research that's been done in this area before.

29:26.360 --> 29:32.960
And I didn't know that the, the, the last time I, I saw some research

29:32.960 --> 29:36.120
like that, it was probably in the nineties and the research might've

29:36.120 --> 29:44.120
been done in the eighties, but the, the conclusion was across a wide range

29:44.160 --> 29:50.040
of different software, different languages, different companies,

29:50.560 --> 29:52.560
different development styles.

29:53.560 --> 29:59.440
The number of bugs is always, I think it's in the order of about one bug per

29:59.440 --> 30:08.240
thousand lines in sort of mature software that is considered as good as it gets.

30:08.280 --> 30:09.640
Can I give you some facts here?

30:09.680 --> 30:11.240
There's a lot of papers.

30:11.640 --> 30:13.720
So you said mature software, right?

30:13.920 --> 30:20.760
So here's a report from a programming analytics company.

30:21.800 --> 30:24.000
Now this is from a developer perspective.

30:24.920 --> 30:26.200
Let me just say what it says.

30:26.200 --> 30:28.280
Cause this is very weird and surprising.

30:28.680 --> 30:35.040
On average, a developer creates 70 bugs per 1000 lines of code, 15

30:35.040 --> 30:38.560
bugs per 1000 lines of code, find their way to the customers.

30:40.000 --> 30:40.920
This is in software.

30:41.160 --> 30:43.440
Oh, I was, I was wrong by an order.

30:44.880 --> 30:50.000
Fixing a bug takes 30 times longer than writing a line of code that I can believe.

30:51.160 --> 30:54.280
75% of a developer's time is spent on debugging.

30:55.160 --> 30:57.160
Um, that's for an average developer.

30:57.160 --> 31:06.120
They, they analyze this 15 argue 1500 hours a year in us alone, $113 billion

31:06.120 --> 31:09.480
to spend annually on identifying and fixing bugs.

31:10.400 --> 31:14.720
And I imagine this is marketing literature for someone who claims to have

31:14.720 --> 31:21.000
a golden bullet or a silver bullet that makes all that investment in fixing bugs

31:21.000 --> 31:26.800
go away, but that, that is usually, uh, not going to, that's not going to happen.

31:27.000 --> 31:30.000
Well, they're, uh, I mean, they're referencing a lot of stuff, of course,

31:30.000 --> 31:35.760
but it is a page, uh, that is, you know, there's a contact us button at the bottom.

31:36.160 --> 31:40.640
Presumably, if you just spend a little bit less than a hundred billion dollars,

31:40.640 --> 31:42.280
we're willing to solve the problem for you.

31:43.640 --> 31:44.080
Right.

31:44.240 --> 31:47.960
And there's also a report on stack exchanges that overflow on the exact same

31:47.960 --> 31:51.960
topic, but when I open it up at the moment, the page says stack overflow

31:51.960 --> 31:53.720
is currently offline for maintenance.

31:54.120 --> 31:55.280
Oh, that is ironic.

31:55.320 --> 31:55.680
Yes.

31:56.320 --> 31:58.120
Uh, by the way, their error page is awesome.

31:58.280 --> 32:02.640
Anyway, I mean, can you believe that number of bugs?

32:02.680 --> 32:03.480
Oh, absolutely.

32:04.000 --> 32:05.040
Isn't that scary?

32:05.040 --> 32:07.440
That's 70 bucks per 1000 lines of code.

32:07.800 --> 32:09.560
So even 10 bucks per 1000 lines.

32:09.560 --> 32:12.920
Well, that's about one bug after every 15 lines.

32:12.920 --> 32:14.880
And that's when you're first typing it in.

32:16.000 --> 32:16.160
Yeah.

32:16.160 --> 32:19.840
From a developer, but like how many bugs are going to be found?

32:20.960 --> 32:22.080
If you're, if you're typing,

32:22.080 --> 32:26.160
well, the development process is extremely iterative.

32:26.360 --> 32:26.640
Yeah.

32:27.000 --> 32:31.720
Typically you don't make a plan for what software you're going to release a year

32:31.720 --> 32:37.680
from now, uh, and work out all the details because actually all the details,

32:37.800 --> 32:46.280
uh, themselves consist, they sort of compose a program and that, that being

32:46.280 --> 32:50.960
a program, all your plans will have bugs in them too, and inaccuracies.

32:51.960 --> 32:58.320
Uh, but what, what you actually do is you do a bunch of typing and I'm,

32:58.400 --> 33:04.440
I'm actually really, I'm a really bad typist that just, I've never

33:04.440 --> 33:06.080
learned to type with 10 fingers.

33:06.920 --> 33:08.040
I, how many do you use?

33:08.840 --> 33:14.760
Well, I use all 10 of them, but not very well, but I never, I never took a typing

33:14.760 --> 33:17.000
class and I never sort of corrected that.

33:17.000 --> 33:22.840
So the first time I, I seriously learned, I had to learn the layout of a, of a

33:22.840 --> 33:29.080
QWERTY keyboard was actually in college in my first programming classes where

33:29.080 --> 33:37.760
we used punch cards and so with my two fingers, I sort of backed out my code.

33:38.920 --> 33:43.120
Watch anyone give you a little coding demonstration.

33:43.840 --> 33:50.680
They'll have to produce like four lines of code and now see how many times they

33:50.680 --> 33:52.040
use the backspace key.

33:52.640 --> 33:57.560
Yeah, because they made a mistake and, and, and some people, especially

33:57.560 --> 34:06.160
when, when someone else is looking, will, will backspace over 20, 30, 40 characters

34:06.600 --> 34:08.760
to fix a typo earlier in the line.

34:08.760 --> 34:13.400
If you're, if you're slightly more experienced, of course you use your

34:13.440 --> 34:17.920
arrow buttons to go or your mouse to, but the mouse is usually slower than,

34:18.320 --> 34:19.200
than the arrows.

34:20.640 --> 34:27.240
But a lot of people, when they type a 20 character word, which is unusual, and

34:27.240 --> 34:31.400
they realized they made a, made a mistake at the start of the word, they backspace

34:31.400 --> 34:34.320
over the whole thing and then retype it.

34:34.320 --> 34:37.080
And sometimes it takes three, four times to get it right.

34:37.080 --> 34:44.240
So I don't know what your definition of bug is, arguably mistyping a word and

34:44.440 --> 34:47.480
correcting it immediately is not a bug.

34:47.480 --> 34:52.400
On the other hand, you, you already do sort of lose time.

34:53.000 --> 34:58.880
And every once in a while, there's sort of a typo that you don't get in that process.

34:59.800 --> 35:04.680
And now you've, you've, you've typed like 10 lines of code and somewhere in the

35:04.680 --> 35:10.440
middle of it, you don't know where yet is a typo or maybe a think-o where you, you

35:10.480 --> 35:14.200
forgot that you had to initialize a variable or something.

35:14.560 --> 35:15.720
But those are two different things.

35:15.720 --> 35:20.360
And I would say, yes, you have to actually run the code to discover that typo, but

35:20.760 --> 35:25.440
forgetting to initialize a variable is a fundamentally different thing because

35:25.440 --> 35:27.200
that thing can go undiscovered.

35:27.720 --> 35:29.800
That depends on the language in Python.

35:29.800 --> 35:30.360
It will not.

35:30.400 --> 35:30.760
Right.

35:30.800 --> 35:36.000
And sort of modern compilers are usually pretty good at catching that even, even

35:36.000 --> 35:36.600
foresee.

35:36.680 --> 35:42.480
So for that specific thing, but actually deeper, it might, there might be another

35:42.480 --> 35:48.120
variable that has initialized, but logically speaking, the one you meant

35:48.200 --> 35:48.800
related.

35:48.840 --> 35:49.200
Yep.

35:51.040 --> 35:53.080
It's like name the same, but it's a different thing.

35:53.080 --> 35:57.880
And you forgot to initialize whatever some counter or some, some basic

35:57.880 --> 35:58.800
variable they're using.

35:58.840 --> 36:00.360
I can tell that you've coded.

36:01.840 --> 36:06.120
By the way, I should mention that I use a Kinesis keyboard, which has the back

36:06.120 --> 36:07.440
space under the thumb.

36:08.000 --> 36:14.160
And one of the biggest reasons I use that keyboard is because you realize in order

36:14.160 --> 36:18.720
to use the backspace on a usual keyboard, you have to stretch your pinky out.

36:20.560 --> 36:26.200
And like the, for most normal keyboards, the backspace is under the pinky.

36:26.640 --> 36:31.840
And so I don't know if people realize the pain they go through in their life

36:32.760 --> 36:34.960
because of the backspace keep being so far away.

36:34.960 --> 36:37.400
So with the Kinesis, it's right under the thumb.

36:37.400 --> 36:38.920
So you don't have to actually move your hands.

36:39.120 --> 36:45.440
The backspace, what do you do if you're ever not with your own keyboard and you

36:45.440 --> 36:50.120
have to use someone else's PC keyboard that has that standard layout?

36:50.400 --> 36:54.600
So first of all, it turns out that you can actually go your whole life always

36:54.600 --> 36:56.680
having the keyboard with you.

36:56.880 --> 37:00.760
So this, well, except for that, that little tablet that you're using.

37:00.760 --> 37:02.440
So we're note taking right now, right?

37:02.760 --> 37:03.000
Yeah.

37:03.000 --> 37:06.800
So it's very inefficient note taking, but I'm not, I'm just looking stuff up.

37:07.280 --> 37:12.840
Uh, but in most cases I would be actually using the keyboard here right now.

37:13.000 --> 37:16.240
I just don't anticipate you have to calculate how much typing do you

37:16.240 --> 37:20.200
anticipate if I anticipate quite a bit, then I'll just, I have a keyboard.

37:21.320 --> 37:27.240
And same, same with the, I mean, the embarrassing I've accepted being the

37:27.240 --> 37:32.840
weirdo that I am, but you know, when I go on an airplane and I anticipate to do

37:33.240 --> 37:38.240
programming or a lot of typing, I will have a laptop that will pull out a

37:38.240 --> 37:41.320
Kinesis keyboard in addition to the laptop.

37:41.680 --> 37:43.000
And it's just who I am.

37:43.000 --> 37:44.920
You have to, you have to accept who you are.

37:45.400 --> 37:50.160
Um, but also it's a, you know, for a lot of people, for me, certainly

37:50.160 --> 37:54.520
there's a comfort space where there's a certain kind of setups that

37:54.520 --> 37:56.560
are, um, maximize productivity.

37:57.200 --> 38:02.720
And, um, it's like some people have a warm blanket that they like when

38:02.720 --> 38:07.520
they watch a movie, I like the Kinesis keyboard takes me to, uh, a place of

38:07.520 --> 38:13.520
focus and I still mostly, I, I'm trying to make sure I use the state of the art

38:13.520 --> 38:18.680
IDs for everything, but my comfort place, just like the Kinesis keyboard is still

38:18.680 --> 38:24.240
Emacs so I still use that.

38:24.640 --> 38:29.240
I still, I mean, that's one of some of the debates I have with myself about

38:29.240 --> 38:34.760
everything from a technology perspective is how much to hold onto the tools you're

38:34.760 --> 38:40.520
comfortable with versus how much to invest in using modern tools and the

38:40.520 --> 38:45.400
signal that the communities provide you with is the noisy one because a lot of

38:45.400 --> 38:49.640
people year to year get excited about new tools and you have to make a prediction.

38:50.120 --> 38:54.400
Are these tools defining a new generation of something that will transform

38:54.400 --> 38:58.880
programming or is this just a fad that will pass certainly with

38:58.880 --> 39:03.920
JavaScript frameworks and, uh, front end and back end of the web.

39:04.120 --> 39:06.640
There's a lot of different styles that came and went.

39:07.920 --> 39:10.440
I remember learning, um, what was it called?

39:10.440 --> 39:11.120
The action script.

39:11.440 --> 39:16.880
I remember for flash, um, you know, learning how to program in flash, uh,

39:16.880 --> 39:20.520
learning how to design, do graphic animation, all that kind of stuff.

39:20.520 --> 39:22.520
A flash same with Java applets.

39:22.560 --> 39:26.560
I remember creating quite a lot of Java applets thinking that this potentially

39:26.560 --> 39:29.120
defines the future of the web and did not.

39:29.320 --> 39:34.720
Well, you know, in most cases like that, the particular technology

39:35.320 --> 39:43.200
eventually gets replaced, but many of the concepts that the technology

39:43.240 --> 39:51.800
introduced or made accessible first are preserved of course, because yeah, we're

39:51.800 --> 39:58.800
not using Java applets anymore, but the notion of reactive web pages that sort

39:58.800 --> 40:05.800
of contain little bits of code that respond directly to something you do,

40:05.800 --> 40:11.040
like pressing a button or a link or hovering even, uh, is, has certainly

40:11.040 --> 40:19.160
not gone away and that those animations that were made painfully complicated

40:19.160 --> 40:26.040
with flash, I mean, flash was an innovation when it first came up and

40:26.160 --> 40:32.840
when it was replaced by JavaScript equivalent stuff, it was a somewhat

40:32.840 --> 40:37.200
better way to do animations, but those animations are still there.

40:37.680 --> 40:45.040
Not all of them, but, but sort of, again, there is an evolution and often, so

40:45.040 --> 40:50.160
often with technology that the sort of the technology that was eventually

40:50.160 --> 40:58.160
thrown away or replaced was still essential to, to sort of get started.

40:58.240 --> 41:01.120
There wouldn't be jet planes without propeller planes.

41:01.840 --> 41:05.920
I bet you, but from a user perspective, yes.

41:05.920 --> 41:06.840
From the feature set.

41:06.840 --> 41:07.280
Yes.

41:07.680 --> 41:14.280
But I, from a programmer perspective, it feels like all the time I've

41:14.280 --> 41:20.240
spent with action script all the time, I spent with Java on the applet

41:20.240 --> 41:21.520
side for the GUI development.

41:21.560 --> 41:22.720
I, well, no Java.

41:22.720 --> 41:26.680
I have to push back that that was useful that because it transfers,

41:26.680 --> 41:28.480
but the flash doesn't transfer.

41:28.480 --> 41:34.720
So some things you learn and invest time in what you learned, the skill

41:34.720 --> 41:43.120
you picked up learning action script was sort of, it was perhaps a super

41:43.120 --> 41:48.400
valuable skill at the time you picked it up, if you, if you, if you learned

41:48.400 --> 41:57.480
action script early enough, but that skill is no longer in demand.

41:57.520 --> 42:00.400
Well, that's the calculation you have to make when you're learning new things.

42:00.400 --> 42:02.960
Like today, people start learning programming today.

42:02.960 --> 42:07.440
I'm trying to, to see what are the new languages to try?

42:07.440 --> 42:09.720
What are the new systems to try that?

42:10.160 --> 42:13.640
What are the new ideas to try to, to keep, keep improving?

42:13.640 --> 42:16.120
That's, that's why we start when we're young.

42:16.120 --> 42:16.560
Right.

42:17.320 --> 42:22.480
When, when we're, but that seems very true to me that, that when you're young, you

42:22.480 --> 42:27.360
have your whole life ahead of you and you're, you're allowed to make mistakes.

42:27.400 --> 42:32.440
In fact, you should, you should feel encouraged to, to do a bit of stupid

42:32.440 --> 42:38.520
stuff, try not to get yourself killed or seriously maimed, but try stuff

42:38.520 --> 42:46.480
that deviates from, from what everybody else is doing and like nine out of 10

42:46.480 --> 42:51.600
times, you'll just learn why everybody else is not doing that or why everybody

42:51.600 --> 42:53.160
else is doing it some other way.

42:53.600 --> 42:59.200
And one out of 10 times you sort of, you discover something that's

42:59.200 --> 43:01.600
better or that's, that somehow works.

43:01.600 --> 43:07.360
I mean, there are all sorts of crazy things that were invented by accident,

43:07.760 --> 43:10.560
by people trying, trying stuff together.

43:11.160 --> 43:14.680
That's great advice to try random stuff, make a lot of mistakes.

43:14.720 --> 43:19.520
Once you're married with kids, you're probably going to be a little more risk

43:19.520 --> 43:24.040
averse because now there's more at stake and you've already hopefully had some

43:24.040 --> 43:27.200
time where you, where you were experimenting with crazy shit.

43:27.920 --> 43:31.440
I like how marriage and kids solidifies your choice of programming language.

43:31.880 --> 43:36.520
How does that, the Robert Frost poem with the road less taken, which I

43:36.520 --> 43:40.600
think is misinterpreted by most people, but that anyway, I feel like the

43:40.600 --> 43:45.400
choices you make early on, especially if you go all in, they're going to define

43:45.400 --> 43:50.560
the rest of your life's trajectory in a way that like you basically are picking

43:50.560 --> 43:51.120
a camp.

43:51.160 --> 43:57.200
So, um, you know, there's, if you invest a lot in PHP, if you invest a lot in dot

43:57.200 --> 44:03.400
net, if you invest a lot in JavaScript, you're going to stick there.

44:04.400 --> 44:06.520
You that's, that's your life journey.

44:07.000 --> 44:13.600
It's very hard to only as far as that technology remains relevant.

44:13.880 --> 44:14.200
Yes.

44:14.280 --> 44:14.520
Yes.

44:14.560 --> 44:24.120
I mean, if, if at age 16, you learn coding in C and by the time you're 26, C

44:24.160 --> 44:31.000
is like a dead language, then there's still time to switch.

44:31.760 --> 44:37.040
There's probably some kind of survivor bias or whatever it's called in, in sort

44:37.040 --> 44:42.720
of your observation that, that you pick a camp because there are many different

44:42.720 --> 44:49.280
camps to pick and if you picked dot net, then, then you can coast for the rest of

44:49.280 --> 44:54.960
your life because that technology is now so ubiquitous, of course, that it's even

44:54.960 --> 44:58.480
if it's, if it's bound to die, it's going to take a very long time.

44:59.000 --> 45:06.240
Well, for me personally, I had a very difficult and in my own head, brave leap

45:06.240 --> 45:10.400
that I had to take relevant to our discussion, which is most of my life I

45:10.400 --> 45:12.120
programmed in C and C plus plus.

45:12.920 --> 45:18.080
And so, uh, having that hammer, everything looked like a nail.

45:18.600 --> 45:22.640
So I would literally even do scripting and C plus plus, like I would create

45:22.640 --> 45:24.400
programs, I do script like things.

45:24.960 --> 45:30.480
And, uh, when I first came to Google and, and before then it became already

45:30.800 --> 45:35.280
before TensorFlow, before all of that, there was a growing realization that C

45:35.280 --> 45:38.120
plus plus is not the right tool for machine learning.

45:38.720 --> 45:40.040
We could talk about why that is.

45:40.040 --> 45:41.200
It's unclear why that is.

45:41.240 --> 45:46.200
A lot of things has to do with community and culture and how it emerges

45:46.200 --> 45:50.160
and stuff like that, but for me, they decided to take the leap to Python.

45:50.600 --> 45:55.480
Like all out basically switched completely from C plus plus, except for,

45:56.280 --> 45:58.640
uh, highly performant robotics applications.

45:58.640 --> 46:02.000
There were still, um, there's still a culture of C plus plus

46:02.000 --> 46:03.400
in the space of robotics.

46:04.400 --> 46:05.720
That was a big leap.

46:06.800 --> 46:10.440
Like I had to, you know, like, like, uh, people have like existential

46:10.880 --> 46:13.080
crises or midlife crises or whatever.

46:13.360 --> 46:17.480
You had to realize almost like walking away from, uh, from a person you love.

46:18.480 --> 46:22.520
Um, cause I was sure that C plus plus would have to be a lifelong companion

46:23.040 --> 46:24.640
for a lot of problems I would want to solve.

46:24.640 --> 46:26.040
C plus plus would be there.

46:26.240 --> 46:29.680
And it was a question to say, well, that might not be the case because C

46:29.680 --> 46:32.680
plus plus is still one of the most popular languages in the world.

46:32.680 --> 46:35.080
One of the most used, one of the most dependent on.

46:35.120 --> 46:38.840
It's also still evolving quite a bit.

46:38.920 --> 46:45.880
I mean, that, that is not a sort of a fossilizing community.

46:46.240 --> 46:46.520
Yes.

46:46.520 --> 46:51.320
They, they are doing great innovative work actually, but the sort of their

46:51.320 --> 46:56.320
innovations are hard to follow if you're not already a hardcore C plus plus user.

46:56.520 --> 46:57.880
Well, this was the thing.

46:57.920 --> 46:58.720
It pulls you in.

46:58.720 --> 46:59.480
It's a rabbit hole.

46:59.480 --> 47:02.960
I was a hardcore, the meta programming template programming.

47:02.960 --> 47:07.920
Like I would start using the modern C plus plus as it developed, right?

47:07.920 --> 47:11.800
Not just the, not, not just the shared pointer and the garbage collection

47:11.800 --> 47:15.080
as you, that makes it easier for you to work with some of the flaws.

47:15.560 --> 47:18.840
But the detail, like the meta programming, the, the crazy stuff

47:18.840 --> 47:20.440
that's, that's coming out there.

47:20.720 --> 47:25.720
But then you have to just empirically look and step back and say, what

47:25.720 --> 47:28.520
language am I more productive in?

47:29.840 --> 47:36.720
Sorry to say what language do I enjoy my life with more and, uh, readability

47:36.720 --> 47:39.960
and able to think through and all that kind of stuff that those questions are

47:40.000 --> 47:45.440
harder to ask when you already have a loved one, which in my case was C plus

47:45.440 --> 47:51.880
plus, and then there's Python, uh, like that meme was the grass is greener

47:51.880 --> 47:52.560
on the other side.

47:52.600 --> 47:58.000
Am I just infatuated with a new fad, new cool thing, or is this actually

47:58.000 --> 47:59.120
going to make my life better?

47:59.120 --> 48:01.600
And I think a lot of people face that kind of decision.

48:01.920 --> 48:03.480
It was a difficult decision for me.

48:04.080 --> 48:08.920
Um, when I made it at this time, it's an obvious switch if you're into machine

48:08.920 --> 48:12.760
learning, but at that time it wasn't quite yet so obvious.

48:13.440 --> 48:16.800
So it was a risk and you know, you have the same kind of stuff with them.

48:17.600 --> 48:22.000
I still, because of my connection to WordPress, I still do a lot of

48:22.000 --> 48:24.160
backend programming and PHP.

48:25.320 --> 48:29.480
Uh, and the question is, you know, no JS Python.

48:29.480 --> 48:32.480
Do you switch to, do you switch backend to any of those?

48:33.480 --> 48:35.920
Programming is there's the case for no JS for me.

48:36.280 --> 48:40.440
Well, more and more and more of the front end, it runs in JavaScript.

48:41.920 --> 48:45.000
Um, and fascinating, cool stuff is done as JavaScript.

48:45.440 --> 48:48.080
Maybe use the same programming language for the backend as well.

48:48.840 --> 48:52.600
Uh, the case for Python for the backend is, well, you're doing so much

48:52.720 --> 48:56.080
programming outside of the web in Python.

48:56.440 --> 48:58.240
So maybe use Python for the backend.

48:58.760 --> 49:03.280
And then the case for PHP, well, most of the web still runs a PHP.

49:04.120 --> 49:05.960
You have a lot of experience with PHP.

49:07.000 --> 49:09.680
Why, uh, fix something that's not broken.

49:09.960 --> 49:13.440
Those are my own personal struggles, but I think they reflect the struggles

49:13.440 --> 49:16.800
of a lot of people with different programming languages, with different

49:16.840 --> 49:18.040
problems they're trying to solve.

49:18.560 --> 49:19.400
It's a weird one.

49:19.640 --> 49:21.920
And there, there's not a single answer, right?

49:21.920 --> 49:27.760
Because depending on how much time you have to learn new stuff, where you

49:27.760 --> 49:32.040
are in your life, what, what you're currently working on, who you want to

49:32.040 --> 49:34.440
work with, what communities you like.

49:35.320 --> 49:37.160
There's not one right choice.

49:37.760 --> 49:43.680
Maybe if you, if you sort of, if you can look back 20 years, you can say, well,

49:43.680 --> 49:50.080
that whole detour through action script was a waste of time, but nobody could

49:50.080 --> 49:57.200
know that, so you can't, you can't beat yourself up over that, uh, you just

49:57.200 --> 50:02.160
need to accept that not every choice you make is going to be perfect.

50:02.200 --> 50:06.880
Maybe sort of keep a plan B in the back of your mind.

50:08.080 --> 50:10.800
Uh, but don't, don't overthink it.

50:11.600 --> 50:17.360
Don't, don't try to sort of, don't, don't create a spreadsheet with like,

50:18.480 --> 50:23.480
where you're trying to estimate, well, if I learn this language, I expect to

50:23.480 --> 50:26.160
make X million dollars in a lifetime.

50:26.160 --> 50:30.600
And if I learned that language, I expect to make why million dollars in a

50:30.600 --> 50:36.360
lifetime and which, which is higher and what, which has more risk and where's

50:36.360 --> 50:44.480
the chance that it's like picking, picking a stock kind of, kind of, but,

50:44.520 --> 50:51.040
uh, I think with stocks, you can do diversifying your investment is good

50:51.680 --> 50:57.720
with productivity in life, boy, that spreadsheet is possible to construct.

50:59.080 --> 51:03.000
Like if you actually carefully analyze what your interests in life are, where

51:03.000 --> 51:08.680
you think you can maximally impact the world, there really is better and worse

51:08.680 --> 51:10.200
choices for programming language.

51:10.440 --> 51:14.720
They're not just about the syntax, but about the community, about where you

51:14.720 --> 51:19.640
predict the community's headed, uh, what large systems are programmed in that.

51:19.640 --> 51:24.040
But can you create that spreadsheet because that's sort of, you're mentioning

51:24.040 --> 51:28.520
a whole bunch of inputs that go into that spreadsheet where you have to estimate

51:28.520 --> 51:33.400
things that are very hard to measure and even harder, I mean, they're, they're

51:33.400 --> 51:38.240
hard to measure retroactively and they're even harder to predict, like

51:38.760 --> 51:40.440
what is the better community?

51:41.120 --> 51:46.200
Well, better is, is one of those incredibly difficult words.

51:46.560 --> 51:49.040
What's better for you is not better for someone else.

51:49.320 --> 51:51.600
But we're not doing a public speech about what's better.

51:51.600 --> 51:54.440
We're doing a personal spiritual journey.

51:54.800 --> 51:59.680
I can determine a circle of friends, circle, circle one and circle two.

51:59.680 --> 52:03.320
And I can have a bunch of parties with one and a bunch of parties with two.

52:03.680 --> 52:08.160
And then write down or take a mental note of what made me happier.

52:08.600 --> 52:08.960
Right.

52:09.160 --> 52:13.000
And that, you know, you have, if you're a machine learning person, you want to say,

52:13.000 --> 52:18.320
okay, I want to build a large company that does, that is grounded in machine

52:18.320 --> 52:23.080
learning, but also has a sexy interface that has a large impact in the world.

52:23.320 --> 52:24.720
What languages do I use?

52:25.280 --> 52:26.760
You look at what Facebook is using.

52:26.760 --> 52:28.000
You look at what Twitter is using.

52:28.360 --> 52:33.920
Then you look at performant more newer languages like Rust, or you look at

52:33.960 --> 52:37.800
languages that have taken that most of the community uses in the machine

52:37.800 --> 52:39.040
learning space, that's Python.

52:39.600 --> 52:42.200
And you can like think through, you can hang out and think through it.

52:42.280 --> 52:47.000
And it's, it's always a invest and the, the level of activity of the

52:47.000 --> 52:48.440
community is also really interesting.

52:48.440 --> 52:52.280
Like you said, C plus plus and Python are super active in terms of the

52:52.280 --> 52:53.880
development of the language itself.

52:54.560 --> 52:59.400
But do you think that you can make objective choices there?

52:59.520 --> 53:02.480
No, no, no, but there's a gut you build up.

53:02.520 --> 53:05.280
Like don't you, don't you believe in that gut feeling?

53:05.280 --> 53:07.120
Everything is very subjective.

53:07.160 --> 53:11.560
And yes, you most certainly can have a gut feeling and your gut can also be wrong.

53:11.920 --> 53:15.520
That's why there are billions of people because they're not all right.

53:16.000 --> 53:21.120
I mean, clearly there are more people living in the Bay area who have plans

53:21.120 --> 53:24.520
to sort of create a Google sized company.

53:25.000 --> 53:29.000
Then there's room in the world for Google sized companies, and they're

53:29.000 --> 53:32.720
going to have to duke it out in the market space.

53:33.120 --> 53:36.640
And there's many more choices than just the programming language.

53:37.080 --> 53:40.640
Speaking of which, let's go back to the boat with the, with the

53:40.640 --> 53:42.560
fisherman who's tuned out long ago.

53:43.360 --> 53:44.400
Let's talk to the programmer.

53:44.640 --> 53:48.800
Let's jump around and go back to see Python that we tried to define as

53:48.800 --> 53:50.160
the reference implementation.

53:50.440 --> 53:54.240
And one of the big things that's coming out in three dot 11, what's the right

53:54.240 --> 53:58.760
way to, we tend to say three dot 11 because it really was like we went three

53:58.760 --> 54:02.160
dot eight, three dot nine, three dot 10, three dot 11, and they're

54:02.160 --> 54:04.480
planning to go up to three dot 99.

54:05.120 --> 54:05.760
99.

54:06.120 --> 54:07.200
What happens after 99?

54:07.520 --> 54:09.320
Probably just three dot 100.

54:09.480 --> 54:10.400
What if I make it there?

54:10.600 --> 54:10.920
Okay.

54:11.800 --> 54:13.120
And go all the way to four 20.

54:13.280 --> 54:13.760
I got it.

54:13.800 --> 54:15.320
Forever Python V3.

54:15.320 --> 54:18.120
We'll talk about four, but more for fun.

54:20.120 --> 54:22.320
So three dot 11 is coming out.

54:22.320 --> 54:25.560
One of the big sexy things in it is it'll be much faster.

54:25.560 --> 54:32.400
So how did you beyond hiring a great team or working with a great team, make it faster?

54:32.400 --> 54:36.000
What are some ideas, uh, that may makes it faster?

54:37.200 --> 54:42.240
It has to do with simplicity of software versus performance.

54:43.080 --> 54:50.200
And so even though C is known to be a low level language, which is great for writing

54:50.320 --> 54:57.280
sort of a high performance language interpreter, when I originally started

54:57.720 --> 55:07.920
Python or see Python, I didn't expect there would be great success and fame in my future.

55:08.920 --> 55:20.040
Uh, so I, I tried to get something working and useful, uh, in about three months.

55:21.240 --> 55:23.920
And so I, I sort of, I cut corners.

55:25.560 --> 55:30.160
I borrowed ideas left and right when it comes to language design,

55:30.160 --> 55:32.000
as well as implementation.

55:32.800 --> 55:37.480
Uh, I also wrote much of the code as simple as it could be.

55:38.640 --> 55:45.040
And there, there are like, there are many things that you can code

55:45.600 --> 55:48.960
more efficiently by adding more code.

55:49.960 --> 55:57.640
It's a bit of a sort of a time space trade off where you can compute a certain

55:57.640 --> 56:01.040
thing from a small number of inputs.

56:02.080 --> 56:07.560
Uh, and every time you get presented with a new input, uh, you do the whole

56:07.560 --> 56:12.400
computation from the top that can be simple looking code.

56:12.400 --> 56:13.920
It's easy to understand.

56:13.920 --> 56:15.680
It's easy to reason about that.

56:15.760 --> 56:20.320
You can, you can tell quickly that it's correct in, at least in the sort

56:20.320 --> 56:26.480
of mathematical sense of correct, uh, because it's implemented in C.

56:26.480 --> 56:35.400
Maybe it performs relatively well, but over time as sort of, as the

56:35.400 --> 56:42.600
requirements for that code and the need for performance go up, you might

56:42.600 --> 56:50.080
be able to rewrite that same algorithm using more memory, maybe remember

56:50.080 --> 56:54.760
previous results so you don't have to recompute everything from scratch.

56:54.760 --> 56:58.840
Like the, the classic example is computing prime numbers.

56:59.400 --> 57:02.400
Like is 10 a prime number?

57:03.360 --> 57:06.240
Well, you sort of, is it divisible by two?

57:06.280 --> 57:07.600
Is it divisible by three?

57:07.640 --> 57:09.240
Is it divisible by four?

57:09.600 --> 57:12.640
And we go all the way to, is it divisible by nine?

57:13.480 --> 57:16.960
And it is not, well, actually 10 is divisible by two.

57:16.960 --> 57:20.560
So there we stop, but say 11 is divisible by 10.

57:20.680 --> 57:23.360
The answer is nine is no 10 times in a row.

57:23.360 --> 57:25.680
So now we know 11 is a prime number.

57:26.840 --> 57:30.280
On the other hand, if we already know that two, three, five, and

57:30.280 --> 57:34.440
seven are prime numbers, and you know a little bit about the mathematics

57:34.480 --> 57:39.880
of how prime numbers work, you know that if you have a rough estimate

57:39.880 --> 57:45.000
for the square root of 11, you don't actually have to check, is it divisible

57:45.000 --> 57:47.720
by four or is it divisible by five?

57:47.720 --> 57:51.280
You, all you have to check in the case of 11 is, is it divisible by two?

57:51.280 --> 57:52.600
Is it divisible by three?

57:53.640 --> 58:00.040
Because take 12, if it's divisible by four, well, 12 divided by four is three.

58:00.040 --> 58:04.600
So you, you should have come across the question, is it divisible by three first?

58:05.760 --> 58:09.680
So if you know basically nothing about prime numbers, except the

58:09.680 --> 58:18.480
definition, maybe you go for X from two through N minus one is N divisible by X.

58:19.320 --> 58:26.080
And then at the end, if you got, uh, all nos, uh, for every single one of those

58:26.080 --> 58:29.560
questions, you know, oh, it must be a prime number.

58:29.560 --> 58:34.360
Well, the first thing is you can stop iterating when you find a yes answer.

58:35.040 --> 58:40.280
And the second is you can also stop iterating when you have reached the

58:40.280 --> 58:46.600
square root of N, because you know that if it has a divisor larger than, than

58:46.600 --> 58:50.440
the square root, it must also have a divisor smaller than the square root.

58:51.440 --> 58:55.840
Then you say, oh, except for two, we don't need to bother with checking

58:55.840 --> 58:59.360
for even numbers because all even numbers are divisible by two.

58:59.360 --> 59:04.160
So if it's divisible by four, we would already have come across the

59:04.160 --> 59:05.880
question, is it divisible by two?

59:05.880 --> 59:09.880
And so now you go special case check, is it divisible by two?

59:09.880 --> 59:12.600
And then you just check three, five, seven, 11.

59:13.400 --> 59:18.880
Uh, and so now you've, you sort of reduced your search space by 50% again, by,

59:19.080 --> 59:21.640
by skipping all the even numbers it kept for two.

59:22.440 --> 59:28.120
If you think a bit more about it, or you just read in your book about the history

59:28.120 --> 59:33.720
of math, one of the first algorithms ever written down, all you have to do

59:33.720 --> 59:38.880
is check, is it divisible by any of the previous prime numbers that are smaller

59:38.880 --> 59:46.960
than the square root and before you get to a better algorithm than that, you

59:46.960 --> 59:51.920
have to have several PhDs in, in discrete math.

59:52.400 --> 59:53.800
So that's as much as I know.

59:54.120 --> 59:57.720
So of course that same story applies to a lot of other algorithms,

59:57.720 --> 01:00:02.960
string matching is a good example of how to come up with an efficient algorithm.

01:00:02.960 --> 01:00:06.520
And sometimes the more efficient algorithm is not so much more

01:00:06.520 --> 01:00:11.800
complex than the inefficient one, but that's an art and it's not always the

01:00:11.800 --> 01:00:17.080
case in the general cases, the more performant the algorithm, the more

01:00:17.080 --> 01:00:20.280
complex it's going to be, there's a, there's a kind of trade off.

01:00:20.640 --> 01:00:27.120
The simpler algorithms are also the ones that people invent first, because

01:00:27.120 --> 01:00:31.960
when you're looking for a solution, you look at the simplest way to get there

01:00:31.960 --> 01:00:38.480
first, and so if there is a simple solution, even if it's not the best

01:00:38.480 --> 01:00:45.320
solution, not the fastest or the most memory efficient or whatever, a

01:00:45.320 --> 01:00:50.960
simple solution and simple is fairly subjective, but mathematicians have

01:00:50.960 --> 01:00:55.600
also thought about sort of what is a good definition for simple in the case

01:00:55.600 --> 01:01:03.400
of algorithms, but the simpler, the simpler solutions tend to be easier

01:01:03.400 --> 01:01:09.360
to follow for other programmers who haven't made a study of a particular field.

01:01:09.360 --> 01:01:14.400
And when I, when I started with Python, I, I was a good programmer in general.

01:01:14.400 --> 01:01:18.400
I knew sort of basic data structures and knew the C language pretty well.

01:01:19.240 --> 01:01:27.920
But there were many areas where I was only somewhat familiar with the state of

01:01:27.920 --> 01:01:36.000
the art, and so I, I picked in many cases, the simplest way I could solve a

01:01:36.000 --> 01:01:40.040
particular sub problem, because when you, when you're designing and implementing

01:01:40.040 --> 01:01:44.520
a language, you have to like, you have many hundreds of little problems to

01:01:44.560 --> 01:01:51.720
solve, and you have to have solutions for every one of them before you can, can

01:01:51.720 --> 01:01:54.560
sort of say, I've invented a programming language.

01:01:56.440 --> 01:02:00.520
First of all, so see Python, what kind of things does it do?

01:02:00.960 --> 01:02:02.040
It's an interpreter.

01:02:02.480 --> 01:02:06.480
It takes in this readable language that we talked about that is Python.

01:02:06.960 --> 01:02:08.080
What is this supposed to do?

01:02:08.120 --> 01:02:15.400
The interpreter, basically it's, it's sort of a recipe for understanding recipes.

01:02:16.680 --> 01:02:24.680
So instead of a recipe that says bake me a cake, we have a recipe for, well, given

01:02:25.400 --> 01:02:30.680
the text of a program, how do we run that program?

01:02:30.760 --> 01:02:34.080
And, and that is sort of the recipe for building a computer.

01:02:34.520 --> 01:02:36.360
The recipe for the baker and the chef.

01:02:37.080 --> 01:02:43.600
What are the algorithmically tricky things that happened to be low hanging

01:02:43.600 --> 01:02:47.800
fruit that could be improved on maybe throughout the history of Python, but

01:02:47.800 --> 01:02:53.520
also now, how is it possible that 3.11 in year 2022, it's possible to get

01:02:53.520 --> 01:02:55.280
such a big performance improvement?

01:02:56.960 --> 01:03:06.320
We focused on a few areas where we, we still felt there was low hanging fruit.

01:03:07.360 --> 01:03:10.560
The biggest one is actually the interpreter itself.

01:03:11.320 --> 01:03:15.720
And this has to do with details of how Python is defined.

01:03:15.720 --> 01:03:20.280
So I didn't know if the fisherman is going to follow this story.

01:03:20.280 --> 01:03:22.240
He already, he already jumped off the boat.

01:03:22.240 --> 01:03:28.720
He's, he's, he's this, yeah, stupid Python is actually, even though it's

01:03:28.720 --> 01:03:33.640
always called an interpreted language, it's, there's also a compiler in there.

01:03:33.640 --> 01:03:35.680
It just doesn't compile to machine code.

01:03:35.960 --> 01:03:43.200
It compiles to byte code, which is sort of code for an imaginary computer

01:03:43.600 --> 01:03:45.360
that is called the Python interpreter.

01:03:45.440 --> 01:03:49.360
So it's compiling code that is more easily digestible by the

01:03:49.360 --> 01:03:51.120
interpreter or is digestible at all.

01:03:51.160 --> 01:03:54.200
It is the code that is digested by the interpreter.

01:03:54.240 --> 01:03:55.200
That's the compiler.

01:03:55.200 --> 01:03:57.840
We tweaked very minor bits of the compiler.

01:03:57.880 --> 01:04:04.400
Almost all the work was done in the interpreter because when you have a

01:04:04.400 --> 01:04:09.640
program, you compile it once and then you run the code a whole bunch of times.

01:04:10.360 --> 01:04:15.800
Or maybe there's one function in the, in the code that gets run many times.

01:04:16.840 --> 01:04:22.440
Uh, now I know that that's sort of people who, who know this field are expecting

01:04:22.440 --> 01:04:26.400
me to at some point say, we built a just in time compiler.

01:04:26.400 --> 01:04:31.360
Actually we didn't, we just made the interpreter, uh, a little more efficient.

01:04:31.880 --> 01:04:34.160
What's a just in time compiler?

01:04:34.360 --> 01:04:40.920
That is a thing from the Java world, although it's now applied to almost all, uh,

01:04:41.280 --> 01:04:44.160
programming languages, especially interpreted ones.

01:04:44.520 --> 01:04:49.440
So you see the components that Python, not like a just in time compiler, but it's

01:04:49.440 --> 01:04:54.800
a compiler that creates byte code that is then fed to the interpreter and the

01:04:54.800 --> 01:04:58.640
compiler, was there something interesting to say about the compiler?

01:04:58.640 --> 01:05:01.720
It's interesting that you haven't changed that, tweaked that at all or much.

01:05:01.920 --> 01:05:07.520
We changed some parts of the byte code, but not very much.

01:05:08.080 --> 01:05:13.200
And so we only had to change the parts of the compiler where we decided that the,

01:05:13.280 --> 01:05:17.480
the breakdown of a Python program in byte code instructions had to be slightly

01:05:17.480 --> 01:05:26.680
different, uh, but that didn't, that didn't gain us the performance, uh,

01:05:27.080 --> 01:05:33.040
improvements that performance improvements were like making the interpreter faster

01:05:33.080 --> 01:05:40.760
in part by sort of removing the fat from some internal data structures used by

01:05:40.760 --> 01:05:48.920
the interpreter, but, uh, the, the key idea is an adaptive specializing interpreter.

01:05:49.760 --> 01:05:50.280
Let's go.

01:05:50.320 --> 01:05:51.720
What is adaptive about it?

01:05:52.080 --> 01:05:53.440
What is specialized about it?

01:05:53.520 --> 01:05:57.920
Well, let me first talk about the specializing part because the adaptive

01:05:57.920 --> 01:06:03.080
part is the sort of the second order effect, but they're both important.

01:06:03.560 --> 01:06:09.640
So byte code is a bunch of machine instructions, but it's an imaginary

01:06:09.640 --> 01:06:16.160
machine, but the machine can do things like call a function, add two numbers,

01:06:17.000 --> 01:06:21.520
print a value, those are sort of typical instructions in Python.

01:06:22.520 --> 01:06:30.640
Uh, and if we take the example of adding two numbers, actually in Python,

01:06:30.640 --> 01:06:33.920
the language, there's no such thing as adding two numbers.

01:06:33.920 --> 01:06:39.800
There's just an, the compiler, uh, doesn't know that you're adding two numbers.

01:06:39.800 --> 01:06:46.320
You might as well be adding two strings or two lists, uh, or two instances of

01:06:46.360 --> 01:06:51.600
some user defined class that happened to implement this operator called add.

01:06:52.400 --> 01:06:57.160
That's a very interesting and fairly powerful mathematical concept.

01:06:57.600 --> 01:07:03.720
It's mostly a user interface trick because it means that a certain category

01:07:03.720 --> 01:07:09.520
of functions, uh, can be written using a symbols, single symbol, the plus sign.

01:07:10.440 --> 01:07:14.240
And sort of a bunch of other functions can be written using another

01:07:14.240 --> 01:07:16.280
single symbol, the multiply sign.

01:07:17.160 --> 01:07:23.680
Uh, so if we take addition, the way traditionally in Python, the add byte

01:07:23.680 --> 01:07:30.360
code was executed is pointers, pointers, and more pointers.

01:07:31.080 --> 01:07:34.000
So first we, we, we have two objects.

01:07:34.040 --> 01:07:38.840
An object is basically a pointer to a bunch of memory that contains more pointers.

01:07:38.880 --> 01:07:40.040
Pointers all the way down.

01:07:40.560 --> 01:07:43.200
Well, not quite, but there, there are a lot of them.

01:07:43.600 --> 01:07:52.240
So to simplify a bit, uh, we look up in one of the objects, what is the type of

01:07:52.240 --> 01:07:57.800
that object and does that object type define an add operation?

01:07:58.720 --> 01:08:04.760
And so you can imagine that there is a sort of a type integer that knows how

01:08:04.760 --> 01:08:06.960
to add itself to another integer.

01:08:07.480 --> 01:08:11.200
And there is a type floating point number that knows how to add itself

01:08:11.840 --> 01:08:13.520
to another floating point number.

01:08:14.160 --> 01:08:20.320
And the integers and floating point numbers are sort of important, I

01:08:20.320 --> 01:08:27.280
think mostly historically, because in the first computers, uh, use the sort

01:08:27.280 --> 01:08:32.000
of the same bit pattern when interpreted as a floating point number had a very

01:08:32.000 --> 01:08:34.560
different value than when interpreted as an integer.

01:08:34.880 --> 01:08:36.320
Can I ask a dumb question here?

01:08:36.440 --> 01:08:36.880
Please do.

01:08:36.880 --> 01:08:41.840
Given the basics of int and float and add, who carries the knowledge

01:08:41.840 --> 01:08:43.560
of how to add two integers?

01:08:44.040 --> 01:08:45.160
Is it the integer?

01:08:45.680 --> 01:08:47.720
It's the type integer versus

01:08:47.760 --> 01:08:50.000
it's the type integer and the type float.

01:08:50.040 --> 01:08:51.360
What about the operator?

01:08:51.480 --> 01:08:59.120
Is the operator just exist as a platonic form possessed by the integer?

01:08:59.400 --> 01:09:08.600
The operator is more like it's an index in a list of functions

01:09:08.840 --> 01:09:11.000
that the integer type defines.

01:09:11.920 --> 01:09:18.760
And so the integer type is really a collection of functions and there

01:09:18.760 --> 01:09:22.720
is an add function and there's a multiply function and there are like

01:09:22.720 --> 01:09:25.160
30 other functions for other operations.

01:09:25.200 --> 01:09:27.000
There's a power function, for example.

01:09:27.960 --> 01:09:34.480
And you can imagine that in, in memory, there is a distinct

01:09:34.480 --> 01:09:37.000
slot for the add operations.

01:09:37.040 --> 01:09:40.960
Let's say the add operation is the first operation of a type and the

01:09:40.960 --> 01:09:43.520
multiply is the second operation of a type.

01:09:44.200 --> 01:09:47.720
So now we take the integer type and we take the floating point type.

01:09:48.920 --> 01:09:54.200
Uh, in both cases, the add operation is the first slot and

01:09:54.200 --> 01:09:55.840
multiply is the second slot.

01:09:56.360 --> 01:10:02.920
But each slot contains a function and the functions are different because

01:10:02.920 --> 01:10:09.680
the, the add to integers function interprets the bit patterns as integers.

01:10:09.760 --> 01:10:18.400
The add to float function interprets the same bit pattern as, as a floating

01:10:18.400 --> 01:10:23.320
point number, and then there is the string data type, which again,

01:10:23.520 --> 01:10:31.240
interprets the, the bit pattern as, uh, the address of a, of a sequence of characters.

01:10:31.800 --> 01:10:36.640
There are lots of lies in that story, but that's, that's sort of a basic idea.

01:10:37.040 --> 01:10:40.480
I can tell, I could tell the fact, the fake news and the fabrication

01:10:40.480 --> 01:10:44.360
going on here at the table, but, uh, where's the optimization?

01:10:44.360 --> 01:10:45.280
Is it on the operator?

01:10:45.280 --> 01:10:47.920
Is it the different inside the integer?

01:10:47.920 --> 01:10:55.960
Optimization is the observation that in a particular line of code.

01:10:57.160 --> 01:11:02.960
So now you, you write your little Python program and you write a function and

01:11:02.960 --> 01:11:07.560
that function sort of takes a bunch of inputs and at some point it adds

01:11:07.560 --> 01:11:09.040
two of the inputs together.

01:11:10.440 --> 01:11:16.120
Now, I bet you, even if you call your function a thousand times, that all

01:11:16.120 --> 01:11:21.880
those calls are likely all going to be about integers because maybe your

01:11:21.880 --> 01:11:28.640
program is all about integers or maybe on that particular line of code where

01:11:28.640 --> 01:11:35.440
that there's that plus operator, every time the program hits that line, the

01:11:35.440 --> 01:11:39.760
variables A and B that B are being added together happen to be strings.

01:11:40.640 --> 01:11:46.720
And so what we do is instead of having this single byte code that says here's

01:11:46.720 --> 01:11:50.560
an ad operation and the implementation of ad is fully generic.

01:11:50.600 --> 01:11:52.920
It looks at the object from the object.

01:11:52.920 --> 01:11:57.240
It looks at the type, then it takes the type and it looks at looks up the

01:11:57.240 --> 01:12:00.040
function pointer, then it calls the function.

01:12:00.400 --> 01:12:04.200
Now the function has to be, has to look at the other argument and it has to

01:12:04.200 --> 01:12:08.440
double check that the other argument has the right type, and then there's

01:12:08.680 --> 01:12:14.200
a bunch of error checking before it can actually just go ahead and add the

01:12:14.200 --> 01:12:15.880
two bit patterns in the right way.

01:12:16.800 --> 01:12:26.760
What we do is every time we execute an ad instruction like that, we keep a

01:12:26.760 --> 01:12:35.920
little note of in the end, after we hit the code that did the addition for

01:12:35.960 --> 01:12:38.560
a particular type, what type was it?

01:12:40.080 --> 01:12:47.200
And then after a few times through that code, if it's the same type all the

01:12:47.200 --> 01:12:56.320
time, we say, oh, so this ad operation, even though it's the generic ad

01:12:56.320 --> 01:13:02.160
operation, it might as well be the ad integer operation and the ad integer

01:13:02.200 --> 01:13:09.120
operation is much more efficient because it just says assume that A and B are

01:13:09.120 --> 01:13:15.200
integers, do the addition operation, do it right there inline and produce the

01:13:15.200 --> 01:13:15.800
result.

01:13:17.600 --> 01:13:24.640
And the big lie here is that in Python, even if you have great evidence that in

01:13:24.640 --> 01:13:29.320
the past it was always two integers that you were adding, at some point in the

01:13:29.320 --> 01:13:33.080
future, that same line of code could still be hit with two floating points or

01:13:33.080 --> 01:13:35.480
two strings, or maybe a string and an integer.

01:13:35.880 --> 01:13:36.840
It's not a great lie.

01:13:36.840 --> 01:13:38.600
That's just the fact of life.

01:13:39.200 --> 01:13:45.800
I didn't account for what should happen in that case in the way I told the story.

01:13:45.880 --> 01:13:48.040
There is some accounting for that.

01:13:48.120 --> 01:13:55.920
And so what we actually have to do is when we have the ad integer operation, we

01:13:55.920 --> 01:14:01.080
still have to check, are the two arguments in fact integers?

01:14:01.760 --> 01:14:08.480
We applied some tricks to make those checks efficient and we know statistically

01:14:08.480 --> 01:14:13.760
that the outcome is almost always, yes, they are both integers.

01:14:15.360 --> 01:14:20.200
And so we quickly make that check and then we proceed with the sort of ad

01:14:20.200 --> 01:14:25.400
integer operation and then there is a fallback mechanism where we say, oops,

01:14:25.400 --> 01:14:26.880
one of them wasn't an integer.

01:14:27.800 --> 01:14:32.000
Now we're going to pretend that it was just the fully generic ad operation.

01:14:32.400 --> 01:14:39.480
We wasted a few cycles believing it was going to be two integers and then we had

01:14:39.480 --> 01:14:46.000
to back up, but we didn't waste that much time and statistically most of the time.

01:14:47.000 --> 01:14:52.520
Basically we were sort of hoping that most of the time we guessed right, because

01:14:52.560 --> 01:14:59.200
if we, if it turns out that we guessed wrong too often, or we didn't have a good

01:14:59.200 --> 01:15:03.960
guess at all, things might actually end up running a little slower.

01:15:04.840 --> 01:15:10.640
So someone with, armed with this knowledge and a copy of the implementation,

01:15:10.640 --> 01:15:15.560
someone could easily construct a counter example where they say, oh, I have a

01:15:15.560 --> 01:15:20.200
program and then now it runs five times as slow in Python 3.11 than it did in

01:15:20.240 --> 01:15:21.160
Python 3.10.

01:15:22.280 --> 01:15:24.320
But that's a very unrealistic program.

01:15:24.320 --> 01:15:28.160
That's, that's just like an extreme fluke.

01:15:29.160 --> 01:15:31.240
It's a fun reverse engineering task though.

01:15:31.600 --> 01:15:32.080
Oh yeah.

01:15:32.160 --> 01:15:37.040
So there's a, people like fun.

01:15:37.080 --> 01:15:37.480
Yes.

01:15:38.000 --> 01:15:46.120
So there's some presumably heuristic of what defines the momentum of saying, you

01:15:46.120 --> 01:15:50.160
know, you seem to be working adding two integers, not two generic types.

01:15:50.640 --> 01:15:53.520
So how do you figure out that heuristic?

01:15:54.160 --> 01:15:59.160
I think that the heuristic is actually, we assume that the weather tomorrow is

01:15:59.160 --> 01:16:00.960
going to be the same as the weather today.

01:16:01.200 --> 01:16:02.840
So you don't need two days of the weather?

01:16:02.960 --> 01:16:03.280
No.

01:16:05.040 --> 01:16:09.840
That is already so much better than, than, than guessing randomly.

01:16:10.240 --> 01:16:12.760
So how do you find this idea?

01:16:13.760 --> 01:16:21.640
Hey, I wonder if instead of adding two generic types, we start assuming that the

01:16:21.640 --> 01:16:26.160
weather tomorrow is the same as the weather today, where do you find the idea

01:16:26.160 --> 01:16:31.920
for that, because that ultimately for you to do that, you have to kind of understand

01:16:31.960 --> 01:16:34.120
how people are using the language, right?

01:16:34.600 --> 01:16:37.760
Python is not the first language to do a thing like this.

01:16:38.160 --> 01:16:43.240
This is a fairly well-known trick, especially from other interpreted

01:16:43.240 --> 01:16:46.480
languages that had reason to be sped up.

01:16:47.080 --> 01:16:51.600
We occasionally look at papers about HHVM, which is for Facebook's

01:16:54.160 --> 01:16:56.880
efficient compiler for PHP.

01:16:57.480 --> 01:17:03.720
There are tricks known from the JVM and sometimes it just comes from academia.

01:17:04.040 --> 01:17:07.560
So the trick here is that the type itself doesn't, the variable

01:17:07.560 --> 01:17:08.920
doesn't know what type it is.

01:17:10.200 --> 01:17:15.120
So this is not a statically typed language where you can, you can afford

01:17:15.120 --> 01:17:17.680
to have a shortcut to saying it's ints.

01:17:17.840 --> 01:17:23.320
This is a trick that is especially important for, for interpreted languages

01:17:23.320 --> 01:17:31.560
with dynamic typing, because if, if the compiler could read in the source, these

01:17:31.560 --> 01:17:36.680
X and Y that we're adding our integers, the compiler can just insert the single

01:17:36.720 --> 01:17:43.120
add machine code, that hardware machine instruction that exists on every

01:17:43.120 --> 01:17:51.640
CPU and did overflows, but because in Python you don't generally declare

01:17:51.640 --> 01:17:56.240
your, the types of your variables, you, you don't even declare the existence

01:17:56.240 --> 01:18:00.200
of your variables, they just spring into existence when you first assign them.

01:18:01.080 --> 01:18:06.080
Which is really cool and sort of helps those beginners because there is less

01:18:06.080 --> 01:18:11.400
bookkeeping they have to learn how to do before they can start playing around with

01:18:11.400 --> 01:18:17.520
code, but it makes the interpretation of the code less efficient.

01:18:17.520 --> 01:18:25.600
And so we're, we're sort of trying to, to make the interpretation more efficient

01:18:25.600 --> 01:18:29.880
without losing the super dynamic nature of the language.

01:18:30.440 --> 01:18:31.760
That's always the challenge.

01:18:31.960 --> 01:18:35.920
3.5 got the PEP 484 type hints.

01:18:36.600 --> 01:18:42.520
What is type hinting and is it used by the interpreter, the hints,

01:18:42.800 --> 01:18:44.400
or is it just syntactic sugar?

01:18:44.480 --> 01:18:50.480
So the type hints is an optional mechanism that people can use.

01:18:50.480 --> 01:18:56.080
And it's especially popular with sort of larger companies that have very

01:18:56.080 --> 01:18:58.480
large code bases written in Python.

01:18:58.640 --> 01:19:01.360
Do you think of it as almost like documentation saying these two

01:19:01.360 --> 01:19:04.400
variables are this type more than documentation?

01:19:04.400 --> 01:19:11.360
I mean, so it, it, it is a sub language of Python where, where you can

01:19:11.360 --> 01:19:13.440
express the types of variables.

01:19:13.440 --> 01:19:18.040
So here's a variable and it's an integer and here's an argument to this function

01:19:18.040 --> 01:19:22.720
and it's a string and here is a function that returns a list of strings, but

01:19:22.720 --> 01:19:24.320
that's not checked when you run the code.

01:19:25.320 --> 01:19:30.120
Exactly there, there is a separate piece of software called a static type

01:19:30.120 --> 01:19:36.000
checker that reads all your source code without executing it and thinks long

01:19:36.000 --> 01:19:42.640
and hard about what it looks from just reading the code that code might be

01:19:42.640 --> 01:19:49.800
doing and double checks if that makes sense, if you take the types as

01:19:49.800 --> 01:19:51.320
annotated into account.

01:19:51.560 --> 01:19:54.000
So this is something you're supposed to run as you develop.

01:19:54.080 --> 01:19:55.200
It's like a linter.

01:19:55.360 --> 01:20:01.120
Yeah, that's definitely a development tool, but the type annotations currently

01:20:01.160 --> 01:20:07.320
are not used for speeding up the interpreter and there are a number of

01:20:07.320 --> 01:20:11.040
reasons many people don't use them.

01:20:11.760 --> 01:20:18.400
Even when they do use them, they sometimes contain lies where the

01:20:18.400 --> 01:20:21.720
static type checker says, everything's fine.

01:20:22.720 --> 01:20:28.080
I cannot prove that this integer is ever not an integer, but at runtime, somehow

01:20:28.080 --> 01:20:35.760
someone manages to violate that assumption and the interpreter ends up

01:20:35.760 --> 01:20:42.280
doing just fine if we started enforcing type annotations in Python, many Python

01:20:42.280 --> 01:20:47.960
programs would no longer work and some Python programs wouldn't even be possible

01:20:47.960 --> 01:20:49.320
because they're too dynamic.

01:20:50.120 --> 01:20:54.400
And so we made a choice of not using the annotations.

01:20:54.400 --> 01:21:02.560
There is a possible future where eventually three, four, five releases in

01:21:02.560 --> 01:21:09.000
the future, we could start using those annotations to sort of provide hints

01:21:09.240 --> 01:21:16.800
because we can still say, well, the source code leads us to believe that these X

01:21:16.800 --> 01:21:23.400
and Y are both integers and so we can generate an add integer instruction, but

01:21:23.400 --> 01:21:32.080
we can still have a fallback that says, oh, if somehow the coded runtime provided

01:21:32.080 --> 01:21:37.240
something else, maybe it provided two decimal numbers, we can still use that

01:21:37.240 --> 01:21:41.440
generic add operation as a fallback, but we're not there.

01:21:41.720 --> 01:21:46.720
Is there currently a mechanism or do you see something like that where you can

01:21:46.720 --> 01:21:53.320
almost add like an assert inside a function that says, please check that my

01:21:53.320 --> 01:22:00.280
type hints are actually mapping to reality, sort of like insert manual static typing.

01:22:00.400 --> 01:22:05.280
There are third party libraries that are in that business.

01:22:05.320 --> 01:22:06.800
So it's possible to do that kind of thing.

01:22:06.800 --> 01:22:12.360
It's possible for a third party library to take a hint and enforce it.

01:22:12.480 --> 01:22:13.720
It seems like a tricky thing.

01:22:14.120 --> 01:22:18.840
Well, what we actually do is, and this, I think this is a fairly unique feature in

01:22:18.840 --> 01:22:24.040
Python, the type hints can be introspective at runtime.

01:22:24.800 --> 01:22:31.840
So while the program is running, they mean Python is a very introspectable language.

01:22:32.240 --> 01:22:37.080
You can look at the variable and ask yourself, what is the type of this, this

01:22:37.080 --> 01:22:42.280
variable, and if that maybe that variable happens to refer to a function, you can

01:22:42.280 --> 01:22:45.080
ask, what are the arguments to the function?

01:22:45.720 --> 01:22:50.560
And nowadays you can also ask, what are the type annotations for the function?

01:22:50.840 --> 01:22:55.400
So the type annotations are there inside the variable as it's at runtime.

01:22:55.680 --> 01:22:59.840
They're mostly associated with the function object, not with each individual

01:22:59.840 --> 01:23:05.920
variable, but you can sort of map from, from the arguments to the variables.

01:23:05.960 --> 01:23:07.720
And that's what a third party library can help.

01:23:07.720 --> 01:23:08.440
Exactly.

01:23:08.480 --> 01:23:14.560
And the problem with that is that all that extra runtime type checking, uh, is

01:23:14.560 --> 01:23:17.360
going to slow your code down instead of speed it up.

01:23:17.600 --> 01:23:25.040
I think, uh, to reference this, uh, sales pitchy blog post that says 75% of

01:23:25.040 --> 01:23:26.760
developers time is spent on debugging.

01:23:27.080 --> 01:23:29.440
I would say that in some cases that might be okay.

01:23:29.840 --> 01:23:33.680
It might be okay to pay the cost of performance for the catching

01:23:33.680 --> 01:23:35.400
of the types, the type errors.

01:23:36.080 --> 01:23:44.080
And in most cases, doing it statically before you ship your code to production

01:23:45.000 --> 01:23:48.720
is more efficient than doing it at runtime piecemeal.

01:23:49.080 --> 01:23:49.360
Yeah.

01:23:50.080 --> 01:23:55.480
Can you tell me about M Y P Y MyPy project?

01:23:56.440 --> 01:23:57.120
What is it?

01:23:57.400 --> 01:24:03.200
What's the mission and in general, what is the future of a static typing in Python?

01:24:04.000 --> 01:24:11.000
Well, so MyPy, uh, was started by a Finnish, uh, developer, Yuka Letoselo.

01:24:11.680 --> 01:24:13.120
So many cool things out of Finland.

01:24:13.520 --> 01:24:15.560
I gotta say just that part of the world.

01:24:15.680 --> 01:24:19.400
I guess people have nothing better to do in those long, cold winters.

01:24:20.800 --> 01:24:21.200
I don't know.

01:24:21.200 --> 01:24:25.400
I think Yuka lived in England when he invented, uh, that stuff actually.

01:24:25.400 --> 01:24:32.160
But MyPy is the original static type checker for Python and the, the

01:24:32.160 --> 01:24:38.520
type annotations that were introduced with PEP 484 were sort of developed

01:24:39.200 --> 01:24:42.960
together with the static type checker.

01:24:43.560 --> 01:24:47.880
And in fact, Yuka had first invented a different syntax that wasn't

01:24:47.880 --> 01:24:49.760
quite compatible with Python.

01:24:50.600 --> 01:24:58.040
And, uh, Yuka and I sort of met at a Python conference in, I think in 2013.

01:24:59.000 --> 01:25:06.840
And we, we sort of came up with a compromise syntax that would not

01:25:06.840 --> 01:25:08.880
require any changes to Python.

01:25:09.760 --> 01:25:15.520
And that would let MyPy sort of be an add on static type checker for Python.

01:25:15.720 --> 01:25:18.200
Just out of curiosity, was it like double colon or something?

01:25:18.200 --> 01:25:20.760
What was he proposing that would break Python?

01:25:21.280 --> 01:25:28.600
I think he was using angular brackets for types like in C++ or Java generics.

01:25:28.920 --> 01:25:29.120
Yeah.

01:25:29.120 --> 01:25:31.720
You can't use angular brackets in Python.

01:25:31.800 --> 01:25:34.240
That would be too tricky for template.

01:25:34.240 --> 01:25:41.720
Well, the key thing is that we already had a syntax for annotations.

01:25:41.720 --> 01:25:44.280
We just didn't know what to use them for yet.

01:25:45.240 --> 01:25:50.880
So type annotations were just the sort of most logical thing to, to use

01:25:50.880 --> 01:25:53.320
that existing dummy syntax for.

01:25:54.280 --> 01:26:02.000
So there was no, there was no syntax for, uh, defining generics directly

01:26:02.080 --> 01:26:03.680
syntactically in the language.

01:26:04.360 --> 01:26:09.840
MyPy literally meant my version of Python, where my refers to Yuka.

01:26:10.840 --> 01:26:18.880
He had a parser that translated MyPy into Python by like doing the type

01:26:18.880 --> 01:26:26.720
checks and then removing the annotations and all the angular brackets, uh, from

01:26:26.720 --> 01:26:32.360
the positions where, where he was using them, but a pre-processor model doesn't

01:26:32.360 --> 01:26:37.320
work very well with the typical workflow of, uh, Python development projects.

01:26:37.920 --> 01:26:38.640
That's funny.

01:26:38.720 --> 01:26:42.520
I mean, that could have been another major split if it became successful.

01:26:42.960 --> 01:26:49.240
Like, uh, if you watch TypeScript versus JavaScript as a, like a split in

01:26:49.240 --> 01:26:50.920
the community over types, right.

01:26:51.040 --> 01:26:52.960
That seems to be stabilizing now.

01:26:53.120 --> 01:26:54.880
It's not necessarily a split.

01:26:54.880 --> 01:27:01.960
There are certainly plenty of people who don't use TypeScript, but just use the

01:27:01.960 --> 01:27:06.880
original JavaScript notation, just like there are many people in the Python

01:27:06.880 --> 01:27:10.800
world who don't use type annotations and don't use static type checkers.

01:27:11.200 --> 01:27:14.080
No, I know, but there is a bit of a split between TypeScript and

01:27:14.080 --> 01:27:15.760
JavaScript, old school JavaScript.

01:27:16.000 --> 01:27:17.080
Yes, whatever.

01:27:17.320 --> 01:27:23.120
Well, in the JavaScript world, transpilers are sort of the standard way of working

01:27:23.120 --> 01:27:28.360
anyway, which is why TypeScript being a transpiler itself is not a big deal.

01:27:28.960 --> 01:27:32.520
And transpilers for people who don't know it's exactly the thing you said with

01:27:32.520 --> 01:27:37.560
MyPy, it's the code, I guess you call it pre-processing code that translates

01:27:37.560 --> 01:27:38.720
from one language to the other.

01:27:38.720 --> 01:27:43.240
And that's part of the culture, part of the workflow of the JavaScript community.

01:27:43.240 --> 01:27:44.400
So that's right.

01:27:44.440 --> 01:27:49.400
At the same time, an interesting development in the JavaScript slash

01:27:49.400 --> 01:27:55.600
TypeScript world at the moment is that there is a proposal under consideration.

01:27:55.600 --> 01:28:01.520
It's only a stage one proposal that proposes to add a feature to JavaScript

01:28:01.520 --> 01:28:10.160
where just like Python, it will ignore certain syntax when running the

01:28:10.160 --> 01:28:17.240
JavaScript code and what it ignores is more or less a superset of the

01:28:17.240 --> 01:28:19.200
TypeScript annotation syntax.

01:28:20.760 --> 01:28:21.160
Interesting.

01:28:21.160 --> 01:28:27.360
So that would mean that eventually if you wanted to, you could take TypeScript

01:28:28.320 --> 01:28:33.520
and you could shove it directly into a JavaScript interpreter without

01:28:33.520 --> 01:28:34.680
transpilation.

01:28:35.480 --> 01:28:39.600
The interesting thing in the JavaScript world, at least the web browser world,

01:28:40.080 --> 01:28:46.480
the web browsers have changed how they deploy and they sort of update their

01:28:46.480 --> 01:28:52.840
JavaScript engines much more quickly than they used to in the early days.

01:28:53.320 --> 01:28:59.360
And so there's much less of a need for translation in JavaScript itself

01:28:59.680 --> 01:29:04.920
because most browsers just support the most recent version of ECMAScript.

01:29:05.440 --> 01:29:10.240
Just in a tangent of a tangent, do you see, if you will recommend somebody

01:29:10.240 --> 01:29:13.360
use a thing, would you recommend TypeScript or JavaScript?

01:29:14.280 --> 01:29:19.040
I would recommend TypeScript just because of the strictness of the typing.

01:29:19.360 --> 01:29:27.560
It's an enormously helpful extra tool that helps you sort of keep your head

01:29:27.560 --> 01:29:30.880
straight about what your code is actually doing.

01:29:32.040 --> 01:29:36.360
I mean, it helps with editing your code.

01:29:36.440 --> 01:29:41.680
It helps with ensuring that your code is not too incorrect.

01:29:42.640 --> 01:29:47.080
And it's actually quite compatible with JavaScript.

01:29:47.080 --> 01:29:52.240
Never mind this syntactic sort of hack that is still years in the future,

01:29:52.920 --> 01:29:58.040
but any library that is written in pure JavaScript can still be used from

01:29:58.040 --> 01:29:59.520
TypeScript programs.

01:30:00.040 --> 01:30:05.360
And also the other way around, you can write a library in TypeScript and then

01:30:05.360 --> 01:30:10.000
export it in a form that is totally consumable by JavaScript.

01:30:10.520 --> 01:30:16.600
That sort of compatibility is sort of the key to the success of TypeScript.

01:30:17.400 --> 01:30:21.520
Yeah, just to look at it, it's almost like a biological system that's evolving.

01:30:21.520 --> 01:30:24.040
It's fascinating to see JavaScript evolve the way it does.

01:30:24.480 --> 01:30:28.960
Well, maybe we should consider that biological systems are just engineering

01:30:28.960 --> 01:30:30.000
systems too, right?

01:30:30.200 --> 01:30:30.640
Yes.

01:30:31.040 --> 01:30:34.640
Just very advanced with more history.

01:30:35.320 --> 01:30:41.040
But it's almost like the most visceral in the JavaScript world because there's

01:30:41.080 --> 01:30:48.120
just so much code written in JavaScript that for its history was messy.

01:30:48.280 --> 01:30:53.680
If you talk about bugs per line of code, I just feel like JavaScript eats the cake

01:30:53.680 --> 01:30:55.040
or whatever the terminology is.

01:30:55.320 --> 01:30:59.520
It beats Python by a lot in terms of number of bugs, meaning like way more

01:30:59.520 --> 01:31:05.480
bugs in JavaScript and then, and then the, obviously the browsers are developed.

01:31:05.480 --> 01:31:07.400
I mean, just, there's so much active development.

01:31:07.440 --> 01:31:12.360
It feels a lot more like evolution where a bunch of stuff is born and dies and

01:31:12.440 --> 01:31:18.960
there's experimentation and debates versus Python is more, um, all that stuff

01:31:18.960 --> 01:31:24.440
is happening, but there's just a longer history of stable working giant software

01:31:24.440 --> 01:31:29.680
systems written in Python versus JavaScript is just a giant, beautiful, I

01:31:29.680 --> 01:31:31.440
would say mess of code.

01:31:31.440 --> 01:31:36.920
It's very different culture and to some extent differences in culture are

01:31:36.920 --> 01:31:40.840
random, but to some extent they, the differences have to do with the

01:31:40.840 --> 01:31:51.440
environment and the fact that JavaScript is primarily the language for developing

01:31:51.960 --> 01:31:58.160
web applications, especially the client side and the fact that it's basically

01:31:58.160 --> 01:32:04.160
the only language for developing web applications makes that community sort

01:32:04.160 --> 01:32:08.800
of just have a different nature than the community of other languages.

01:32:10.640 --> 01:32:16.760
Plus the graphical component, um, and the fact that they're deploying it on all

01:32:16.760 --> 01:32:20.440
kinds of, uh, shapes of screens and devices and all that kind of stuff, it

01:32:20.440 --> 01:32:22.560
just creates a beautiful chaos.

01:32:22.840 --> 01:32:23.920
Anyway, back to my pie.

01:32:24.640 --> 01:32:28.840
So what, okay, you, you met, you talked about a syntax that could work.

01:32:29.520 --> 01:32:30.880
Where does it currently stand?

01:32:31.600 --> 01:32:33.760
What's the future of static typing in Python?

01:32:35.000 --> 01:32:39.720
It is still controversial, but it is much more accepted than when

01:32:39.720 --> 01:32:42.520
MyPy and PEP 484 were, were young.

01:32:43.360 --> 01:32:47.920
What's the connection between a PEP 484 type hints and MyPy?

01:32:48.360 --> 01:32:53.160
MyPy was the original static type checker.

01:32:53.160 --> 01:33:00.880
So it, MyPy quickly evolved from Yuka's own variant of Python to a static

01:33:00.880 --> 01:33:08.200
type checker for Python and, uh, sort of PEP 484 that that was at like a very

01:33:08.200 --> 01:33:13.960
productive year where like many hundreds of messages were exchanged, debating

01:33:13.960 --> 01:33:18.200
the merits of every aspect of, of that PEP.

01:33:19.320 --> 01:33:23.400
And so MyPy is a static type checker for Python.

01:33:23.440 --> 01:33:26.200
It is itself written in Python.

01:33:27.040 --> 01:33:34.400
Most additional static typing features that we introduced in the time since

01:33:34.400 --> 01:33:43.720
three, six, uh, were also prototyped through MyPy MyPy being an open source

01:33:43.720 --> 01:33:49.840
project with a very small number of maintainers was successful enough that

01:33:49.840 --> 01:33:54.720
people said this static type checking stuff for Python is actually worth an

01:33:54.720 --> 01:34:05.160
investment for our company, but somehow they chose not to support making MyPy

01:34:05.160 --> 01:34:12.360
faster, say, or adding new features to MyPy, but, uh, both Google and Facebook

01:34:12.400 --> 01:34:16.800
and later Microsoft developed their own static type checker.

01:34:17.000 --> 01:34:23.080
I think Facebook was one of the first they decided that they wanted to use

01:34:23.120 --> 01:34:31.320
the same technology that they had successfully used for, uh, HHVM because

01:34:31.320 --> 01:34:36.640
they, they sort of, they had a bunch of compiler writers and sort of static

01:34:36.640 --> 01:34:42.840
type checking experts who had written the HHVM compiler, and it was big

01:34:42.840 --> 01:34:49.080
success within the company and they had done it in a certain way, sort of, they

01:34:49.120 --> 01:34:55.720
wrote a big, highly parallel application in an obscure language named OCaml,

01:34:56.320 --> 01:35:00.240
which is apparently mostly very good for writing static type checkers.

01:35:01.080 --> 01:35:01.800
Interesting.

01:35:02.240 --> 01:35:06.120
I have a lot of questions about how to write a static type checker.

01:35:06.120 --> 01:35:07.880
Then that's very confusing.

01:35:07.920 --> 01:35:13.720
Facebook wrote their version and they worked on it in secret for about a year.

01:35:13.720 --> 01:35:16.600
And then they came clean and went to open source.

01:35:17.360 --> 01:35:21.800
Uh, Google in the meantime was developing something called PyType,

01:35:21.800 --> 01:35:28.840
which was mostly interesting because it, as you may have heard, they have

01:35:28.840 --> 01:35:35.200
one gigantic monorepo, so all the code is checked into a single repository.

01:35:35.760 --> 01:35:37.280
Facebook has a different approach.

01:35:37.280 --> 01:35:42.760
So Facebook developed Pyre, which was written in OCaml, which worked

01:35:42.760 --> 01:35:46.160
well with Facebook's development workflow.

01:35:47.440 --> 01:35:51.400
Uh, Google developed something they called PyType, which was

01:35:51.400 --> 01:35:53.320
actually itself written in Python.

01:35:54.320 --> 01:36:01.800
Uh, and it was meant to sort of fit well in their static type checking needs

01:36:01.840 --> 01:36:05.120
in Google's gigantic monorepo.

01:36:05.240 --> 01:36:07.480
So Google has the one giant, got it.

01:36:07.800 --> 01:36:14.240
So the, just to clarify this static type checker, philosophically is the

01:36:14.240 --> 01:36:16.880
thing that's supposed to exist outside of the language itself.

01:36:17.280 --> 01:36:21.320
And it's just a workflow, like a debugger for the programmers, for

01:36:21.320 --> 01:36:25.440
people who don't know a linter, maybe you can correct me, but it's, it's

01:36:25.440 --> 01:36:30.200
a thing that runs through the code continuously pre-processing to find

01:36:30.240 --> 01:36:34.120
issues based on style, documentation.

01:36:34.120 --> 01:36:36.160
I mean, there's all kinds of linters, right?

01:36:36.160 --> 01:36:41.160
It can check that what usual things does a linter do, maybe check that

01:36:41.160 --> 01:36:45.200
you have too many characters in a single line.

01:36:45.720 --> 01:36:50.880
Linters often do static analysis where they try to point out things

01:36:50.880 --> 01:36:55.880
that are likely mistakes, but not incorrect according to the language

01:36:55.880 --> 01:37:01.760
specification, like maybe you have a variable that you never use for

01:37:01.760 --> 01:37:04.240
the compiler that is valid.

01:37:04.280 --> 01:37:08.320
You might sort of, you might be planning to use it in a future

01:37:08.320 --> 01:37:12.720
version of the, of the code and the compiler might just optimize it out.

01:37:12.720 --> 01:37:15.880
But the compiler is not going to tell you, Hey, you're never using this variable.

01:37:16.480 --> 01:37:20.200
A linter will tell you that variable is not used.

01:37:20.200 --> 01:37:24.680
Maybe there's a typo somewhere else where you meant to use it, but you

01:37:24.680 --> 01:37:29.000
accidentally use something else, or there are a number of sort of common

01:37:29.000 --> 01:37:38.040
scenarios and a linter is often a big collection of little heuristics where

01:37:38.040 --> 01:37:42.200
by looking at the combination of how your code is laid out, maybe how it's

01:37:42.200 --> 01:37:51.040
indented, maybe the comment structure, but also just things like definition

01:37:51.040 --> 01:37:56.400
of names, use of names, it'll tell you likely things that are wrong.

01:37:56.400 --> 01:38:02.480
And in some cases linters are, are really style checkers for Python.

01:38:02.520 --> 01:38:07.960
There are a number of linters that check things like, do you use the PEP

01:38:07.960 --> 01:38:13.880
eight recommended naming scheme for your functions and classes and variables?

01:38:14.320 --> 01:38:17.600
Because like classes start with an uppercase and the rest starts with a

01:38:17.600 --> 01:38:21.400
lowercase and there's like differences there.

01:38:21.400 --> 01:38:26.040
And so the linter can tell you, Hey, you have a class that whose first

01:38:26.040 --> 01:38:29.240
letter is not an uppercase letter.

01:38:29.240 --> 01:38:31.520
And that's just, I just find it annoying.

01:38:31.520 --> 01:38:35.840
If I wanted that to be an uppercase letter, I would have typed an uppercase

01:38:35.840 --> 01:38:41.200
letter, but other people find it very comforting that if the linter is no

01:38:41.200 --> 01:38:45.600
longer complaining about their code, that they have followed all the style rules.

01:38:45.960 --> 01:38:48.840
Maybe it's a fast way for a new developer joining a team to

01:38:48.840 --> 01:38:50.000
learn the style rules, right?

01:38:50.040 --> 01:38:56.080
Yeah, there's definitely that, but the best use of a linter is probably not so

01:38:56.080 --> 01:39:02.640
much to, to sort of enforce team uniformity, but to actually help

01:39:02.640 --> 01:39:09.120
developers catch bugs that the compilers for whatever reason don't catch.

01:39:09.640 --> 01:39:11.520
And there's lots of that in Python.

01:39:12.080 --> 01:39:19.200
And so, uh, but a static type checker focuses on, uh, a particular aspect of

01:39:19.200 --> 01:39:23.680
the linting, which I mean, it might probably doesn't care how you name

01:39:23.680 --> 01:39:30.800
your classes and variables, uh, but it is meticulous about when you say that

01:39:30.800 --> 01:39:35.280
there was an integer here and you're passing a string there, it will tell

01:39:35.280 --> 01:39:37.480
you, Hey, that string is not an integer.

01:39:37.480 --> 01:39:38.520
So something's wrong.

01:39:38.520 --> 01:39:43.640
Either, either you were incorrect when you said it was an integer or you're

01:39:43.640 --> 01:39:45.440
incorrect when you're passing into string.

01:39:45.760 --> 01:39:49.520
If this is a race of static type checkers, there's somebody winning.

01:39:49.840 --> 01:39:52.880
As you said, it's interesting that the companies didn't choose to invest

01:39:52.960 --> 01:40:00.960
in this, um, centralized development of my pie is, is there a future for my pie?

01:40:01.880 --> 01:40:06.560
What do you see as the, will one of the companies win out and everybody uses

01:40:06.880 --> 01:40:10.720
like a PI type or whatever Google's is called?

01:40:10.960 --> 01:40:15.840
Well, Microsoft is hoping that, uh, Microsoft's horse in that race

01:40:15.840 --> 01:40:18.160
called PI, right is going to win.

01:40:18.680 --> 01:40:19.840
PI, right, right.

01:40:19.840 --> 01:40:21.760
Like R I G H T.

01:40:22.040 --> 01:40:22.760
Correct.

01:40:22.960 --> 01:40:23.400
Yeah.

01:40:23.400 --> 01:40:29.320
My, my, all my word processors tend to type out, correct that as PI, right?

01:40:29.360 --> 01:40:31.760
The name of the, I don't know what it is.

01:40:32.800 --> 01:40:34.880
Some kind of semi-precious metal.

01:40:35.440 --> 01:40:36.080
Oh, right.

01:40:37.560 --> 01:40:38.080
I love it.

01:40:38.200 --> 01:40:38.640
Okay.

01:40:38.800 --> 01:40:39.920
So, okay.

01:40:39.920 --> 01:40:42.200
That's the Microsoft hope, but it, okay.

01:40:42.200 --> 01:40:44.000
So let me ask the question a different way.

01:40:44.600 --> 01:40:48.360
Is there going to be ever a future where the static type checker gets

01:40:48.360 --> 01:40:49.720
integrated into the language?

01:40:53.160 --> 01:40:59.160
Nobody is currently excited about doing any work towards that.

01:40:59.200 --> 01:41:06.040
That doesn't mean that five or 10 years from now, the situation isn't different.

01:41:06.680 --> 01:41:17.000
Uh, at the moment, all the static type checkers, uh, still evolve at a much

01:41:17.000 --> 01:41:22.280
higher speed than Python and its annotation syntax evolve.

01:41:22.880 --> 01:41:26.360
You get a new release of Python once a year.

01:41:26.520 --> 01:41:31.680
Those are the only times that you can introduce new annotation syntax.

01:41:32.160 --> 01:41:36.480
And there's, there are always people who invent new, new annotation syntax

01:41:36.480 --> 01:41:37.760
that they're trying to push.

01:41:38.640 --> 01:41:45.280
Uh, and worse once we've all agreed that we are going to put some new

01:41:45.280 --> 01:41:47.720
syntax in, we can never take it back.

01:41:48.640 --> 01:41:53.120
At least the sort of deprecating an existing feature takes many releases

01:41:53.120 --> 01:41:57.400
because you have to assume that people started using it as soon as we announced

01:41:57.400 --> 01:42:03.200
it, and then you can't take it away from them right away, you have to start telling

01:42:03.200 --> 01:42:08.720
them, well, this will go away, but we're not going to tell you that it's an error

01:42:08.720 --> 01:42:12.600
yet, and then later it's going to be a warning and then eventually three

01:42:12.600 --> 01:42:14.960
releases in the future, maybe we remove it.

01:42:15.800 --> 01:42:22.280
On the other hand, the typical static type checker still has a release like

01:42:24.600 --> 01:42:29.000
every month, every two months, certainly many times a year.

01:42:30.000 --> 01:42:37.200
Uh, some type checkers also include a bunch of experimental ideas that aren't

01:42:37.240 --> 01:42:40.440
official standard, uh, Python syntax yet.

01:42:41.080 --> 01:42:48.320
Uh, the static type checkers also just get better at discovering things that,

01:42:48.840 --> 01:42:53.360
that sort of are unspecified by the language, but that sort of could make

01:42:53.360 --> 01:42:58.920
sense, and so each static type checker actually has it sort of strong and weak

01:42:58.920 --> 01:42:59.480
points.

01:43:00.040 --> 01:43:00.520
So it's cool.

01:43:00.520 --> 01:43:02.240
It's like a laboratory of experiments.

01:43:02.280 --> 01:43:02.560
Yeah.

01:43:02.640 --> 01:43:04.800
Microsoft, Google and all, and you get to see.

01:43:05.000 --> 01:43:06.560
And you see that everywhere, right?

01:43:06.600 --> 01:43:11.800
Because there's not one single, uh, JavaScript in engine either.

01:43:11.800 --> 01:43:12.920
There is one in Chrome.

01:43:12.920 --> 01:43:14.200
There is one in Safari.

01:43:14.200 --> 01:43:15.720
There is one in Firefox.

01:43:17.120 --> 01:43:19.160
But that said, you said there's not interest.

01:43:19.160 --> 01:43:22.640
I think there is a lot of interest in type hinting, right?

01:43:22.760 --> 01:43:27.920
Uh, in the pep four 84, actually like how many people use that?

01:43:27.960 --> 01:43:30.480
Do you have a sense how many people use?

01:43:30.520 --> 01:43:31.440
Cause it's optional.

01:43:31.440 --> 01:43:32.320
It's a sugar.

01:43:32.920 --> 01:43:39.880
I can't put a number on it, but from the number of packages that do interesting

01:43:39.880 --> 01:43:46.080
things with it at runtime and the fact that there are like now three or four

01:43:46.120 --> 01:43:52.280
very mature type checkers that each have their, their segment of the market.

01:43:52.360 --> 01:43:56.800
And, oh, and then there is a pie charm, which has a sort of more heuristic based

01:43:56.800 --> 01:43:59.760
type checker that also supports the same syntax.

01:44:00.520 --> 01:44:07.800
My assumption is that many, many people developing Python software professionally

01:44:08.640 --> 01:44:15.880
for some kind of production situation are using a static type checker, especially

01:44:15.880 --> 01:44:23.560
any, anybody who has a continuous integration cycle probably has, uh, one

01:44:23.560 --> 01:44:28.640
of the steps in, in their, their testing routine that, that happens for basically

01:44:28.640 --> 01:44:36.040
every, every commit, uh, is run a static type checker and in most, in most cases

01:44:36.040 --> 01:44:37.080
that will be my pie.

01:44:39.600 --> 01:44:41.600
So I think it's pretty popular topic.

01:44:42.840 --> 01:44:49.920
According to this webpage, 20 to 30% of Python, three code bases are using type

01:44:49.920 --> 01:44:50.360
hints.

01:44:51.280 --> 01:44:51.640
Wow.

01:44:51.840 --> 01:44:53.080
I wonder how they measured that.

01:44:53.120 --> 01:44:54.920
Did they just scan all of GitHub?

01:44:55.640 --> 01:44:57.280
Yeah, that's what it looks like.

01:44:57.520 --> 01:45:01.240
They did a quick set, not all of, but like a random sampling.

01:45:03.000 --> 01:45:04.280
So you mentioned pie charm.

01:45:04.920 --> 01:45:07.560
Let me ask you the, uh, the big subjective question.

01:45:09.400 --> 01:45:12.800
What's the best IDE for Python?

01:45:13.240 --> 01:45:16.200
And you're extremely biased now that you're with Microsoft.

01:45:16.840 --> 01:45:20.480
Um, is it pie charm VS code VIM or EMAX?

01:45:21.320 --> 01:45:27.240
Historically, I actually, uh, started out with using VIM, but when it was

01:45:27.240 --> 01:45:34.720
still called VI, uh, for a very long time, I think from the early eighties

01:45:34.720 --> 01:45:41.400
to, uh, I'd say two years ago, I was EMAX user.

01:45:41.960 --> 01:45:42.560
Nice.

01:45:42.760 --> 01:45:54.160
Between I'd say 2013 and 2018, I dabbled with pie charm, uh, mostly because it

01:45:54.160 --> 01:45:56.600
had, had a couple of features.

01:45:56.600 --> 01:46:03.360
I mean, pie charm is like driving an 18 wheeler truck.

01:46:03.360 --> 01:46:11.400
Whereas EMAX is more like driving a, your comfortable Toyota car.

01:46:12.280 --> 01:46:16.000
That's, that's, that you've had for a hundred thousand miles and you know,

01:46:16.000 --> 01:46:18.440
what every little rattle of the car means.

01:46:19.240 --> 01:46:23.480
I was very comfortable in EMAX, uh, but there were certain things it couldn't do.

01:46:23.480 --> 01:46:28.920
It wasn't very good at that sort of, at least the way I had configured it.

01:46:30.840 --> 01:46:35.280
I didn't have very good tooling in EMAX for finding the definition of a function.

01:46:36.640 --> 01:46:36.960
Got it.

01:46:37.440 --> 01:46:46.120
When I was at Dropbox exploring a 5 million line Python code base, uh, just

01:46:46.120 --> 01:46:50.160
grabbing all that code for where there, where is there a class foobar?

01:46:50.480 --> 01:46:54.600
Well, it turns out that if you grab all 5 million lines of code, there

01:46:54.600 --> 01:46:56.480
are many classes with the same name.

01:46:57.920 --> 01:47:04.040
And so pie charm sort of once, once you fired it up and once it's indexed,

01:47:04.200 --> 01:47:07.720
your repository, uh, was very helpful.

01:47:08.120 --> 01:47:13.200
But the soon as I had to edit code, I would jump back to EMAX and do all my

01:47:13.200 --> 01:47:17.520
editing there because I could type much faster and switch between files.

01:47:18.160 --> 01:47:21.680
When I would, when I knew which file I wanted much, much quicker.

01:47:21.680 --> 01:47:26.320
And I never really got used to the, the whole pie charm user interface.

01:47:26.880 --> 01:47:27.200
Yeah.

01:47:27.240 --> 01:47:29.080
I feel torn in that same kind of way.

01:47:29.080 --> 01:47:32.920
Cause I've used pie charm off and on exactly in that same way.

01:47:33.560 --> 01:47:38.760
And I feel like I'm just being an old grumpy man for not learning how to

01:47:38.760 --> 01:47:41.120
quickly switch between files and all that kind of stuff.

01:47:41.120 --> 01:47:42.560
I feel like that has to do with shortcuts.

01:47:42.560 --> 01:47:45.480
That has to do with, um, I mean, you just have to get accustomed

01:47:45.480 --> 01:47:46.640
just like with touch typing.

01:47:46.640 --> 01:47:46.920
Yeah.

01:47:46.920 --> 01:47:49.040
You have to just want to, to learn that.

01:47:49.040 --> 01:47:52.800
I mean, if you don't need it much, you don't need touch typing either.

01:47:53.280 --> 01:47:56.840
You can type with two fingers just fine in the short term, but in the long

01:47:56.840 --> 01:48:01.840
term, your life will become better psychologically and productivity wise.

01:48:01.840 --> 01:48:06.440
If you learn how to type with 10 fingers, if you do a lot of keyboard input,

01:48:06.720 --> 01:48:09.160
but for everyone emails and stuff, right?

01:48:09.200 --> 01:48:13.640
Like you look at the, the next 20, 30 years of your life, you have to

01:48:13.640 --> 01:48:15.320
anticipate where technology is going.

01:48:16.120 --> 01:48:19.560
Um, do you want to invest in handwriting notes?

01:48:19.880 --> 01:48:24.040
Probably not more and more people are doing, uh, typing versus handwriting

01:48:24.040 --> 01:48:25.920
notes, so you can anticipate that.

01:48:26.440 --> 01:48:28.720
So there's no reason to actually practice handwriting.

01:48:28.720 --> 01:48:30.520
There's more reason to practice typing.

01:48:31.600 --> 01:48:36.640
You can actually estimate back to the spreadsheet, the number of paragraphs,

01:48:36.920 --> 01:48:40.280
sentences or words you write for the rest of your life.

01:48:41.200 --> 01:48:45.680
You can probably, you can probably go again with the spreadsheet of my life.

01:48:45.680 --> 01:48:46.120
Yes.

01:48:46.680 --> 01:48:50.120
I mean, all of that is not actual like converted to a spreadsheet,

01:48:50.120 --> 01:48:54.120
but the gut feeling, like I have the same kind of gut feeling about books.

01:48:54.560 --> 01:48:59.560
I've almost exclusively switched to Kindle now for ebook readers, even

01:48:59.560 --> 01:49:04.520
though I still love and probably always will the smell, the feel of a physical

01:49:04.520 --> 01:49:10.240
book and you, the reason I switched to Kindle is like, all right, well,

01:49:10.240 --> 01:49:15.600
this is really paving the future is going to be digital in terms of

01:49:15.600 --> 01:49:18.800
consuming books and content of that nature.

01:49:18.800 --> 01:49:22.000
So you should get, you know, you should let your brain get accustomed

01:49:22.000 --> 01:49:24.720
to that experience and that same way.

01:49:25.000 --> 01:49:27.160
It feels like pie charm or VS code.

01:49:27.200 --> 01:49:34.760
I think by charm is, is the most sort of sophisticated featureful, uh, Python ID.

01:49:35.080 --> 01:49:39.440
It feels like I should probably at some point very soon switch

01:49:39.440 --> 01:49:43.400
entire, like I'm not allowed to use anything else for Python than

01:49:43.400 --> 01:49:45.200
this ID or VS code.

01:49:45.200 --> 01:49:48.760
It doesn't matter, but walk away from Emacs for this particular application.

01:49:49.120 --> 01:49:53.120
So I think I'm limiting myself in the same way that using two fingers

01:49:53.120 --> 01:49:54.520
for typing is limiting myself.

01:49:55.360 --> 01:49:57.080
It's, um, this is a therapy session.

01:49:57.080 --> 01:50:02.680
This is not, I'm not even, but I'm sure a lot of people are thinking of you.

01:50:02.760 --> 01:50:08.920
Uh, I, I think that that's sort of, everybody has to decide for themselves

01:50:09.000 --> 01:50:12.200
which one they want to, to invest more time in.

01:50:13.600 --> 01:50:21.200
I actually ended up giving VS code a very tentative try when I started out

01:50:21.200 --> 01:50:23.400
at Microsoft and really liking it.

01:50:24.520 --> 01:50:32.040
And it sort of, it took me a while before I realized why that was, but, and, and I

01:50:32.040 --> 01:50:37.200
think that actually the founders of VS code may not necessarily agree with me on

01:50:37.200 --> 01:50:47.680
this, but to me, VS code is in a sense, the spiritual successor of Emacs because

01:50:48.520 --> 01:50:55.280
as you probably know, as an old Emacs hack, the key part of Emacs is that it

01:50:55.560 --> 01:51:02.720
it's mostly written in Lisp and that that sort of new features of, of Emacs

01:51:02.720 --> 01:51:08.240
usually update all the list packages and add new list packages.

01:51:08.640 --> 01:51:14.680
And, oh yeah, there's also some very obscure thing improved in the part that's

01:51:14.680 --> 01:51:20.720
not in Lisp, but that's usually not why you would upgrade to a new version of Emacs.

01:51:21.240 --> 01:51:28.480
There's a core implementation that that sort of can read a file and it can put

01:51:28.480 --> 01:51:33.240
bits on the screen and it can sort of manage memory and buffers.

01:51:33.680 --> 01:51:39.280
And then what makes it an editor full of features is all the list packages.

01:51:39.760 --> 01:51:45.280
And of course the design of how the list packages interact with each other and

01:51:45.280 --> 01:51:51.600
with that, that sort of that base layer of, of the core immutable engine, but

01:51:51.800 --> 01:51:57.680
almost everything in that core engine in Emacs case can still be overridden or

01:51:57.680 --> 01:51:58.520
replaced.

01:51:59.320 --> 01:52:12.000
And so VS Code has a similar architecture where there is like a base engine that

01:52:12.000 --> 01:52:13.520
you have no control over.

01:52:14.200 --> 01:52:19.960
I mean, it's open source, but nobody except the people who work on that part

01:52:21.520 --> 01:52:22.600
changes it much.

01:52:23.440 --> 01:52:31.560
And it has a sort of a package manager and a whole series of interfaces for

01:52:31.560 --> 01:52:37.000
packages and an additional series of conventions for how packages should

01:52:37.000 --> 01:52:42.320
interact with the lower layers and with each other and powerful primitive

01:52:42.320 --> 01:52:50.560
operations that let you move the cursor around or select pieces of text or delete

01:52:50.560 --> 01:52:55.600
pieces of text or interact with the keyboard and the mouse and whatever

01:52:55.600 --> 01:52:56.840
peripherals you have.

01:52:58.000 --> 01:53:05.240
And, and so the sort of the, the extreme extensibility and the package ecosystem

01:53:05.680 --> 01:53:12.160
that you, that you see in VS Code is a, is a mirror of very similar architectural

01:53:12.160 --> 01:53:13.640
features in Emacs.

01:53:14.320 --> 01:53:19.640
Well, I'll have to give it a serious try because as far as sort of the hype and

01:53:19.640 --> 01:53:23.320
the excitement in the general programming community, VS Code seems to

01:53:23.320 --> 01:53:23.840
dominate.

01:53:24.360 --> 01:53:30.920
The interesting thing about PyCharm and what is it, PHP Storm, which are these

01:53:30.920 --> 01:53:35.960
JetBrains specific IDs that are designed for one programming language.

01:53:36.400 --> 01:53:41.040
It's interesting to, when an ID is specialized, right?

01:53:41.080 --> 01:53:47.240
They're usually actually just specializations of IntelliJ because underneath

01:53:47.240 --> 01:53:57.440
it's all the same editing engine with different veneer on top, where in VS Code,

01:53:58.400 --> 01:54:04.920
many things you do require loading third-party extensions.

01:54:05.800 --> 01:54:12.200
In PyCharm, it is possible to have third-party extensions, but it is, it is

01:54:12.280 --> 01:54:14.040
a struggle to create one.

01:54:14.560 --> 01:54:14.960
Yes.

01:54:14.960 --> 01:54:17.200
And it's not part of the culture, all that kind of stuff.

01:54:17.240 --> 01:54:23.240
Yeah, we, I remember that it might've been five years ago or so we were trying to

01:54:23.240 --> 01:54:29.640
get some better MyPy integration into PyCharm because MyPy is sort of Python

01:54:29.640 --> 01:54:39.080
tooling and PyCharm had its own type checking heuristic thing that we wanted to

01:54:39.080 --> 01:54:44.360
replace with something based on MyPy because that was what we were using in the

01:54:44.360 --> 01:54:51.880
company and for the guy who was writing that PyCharm extension, it was really a

01:54:51.880 --> 01:55:00.440
struggle to sort of find documentation and get the development workflow going and

01:55:00.440 --> 01:55:02.360
debug his code and all that.

01:55:02.480 --> 01:55:05.240
So that was not a pleasant experience.

01:55:06.080 --> 01:55:08.040
Let me talk to you about parallelism.

01:55:08.720 --> 01:55:14.960
In your post titled reasoning about async IO semaphore, you talk about a fast food

01:55:14.960 --> 01:55:17.120
restaurant in Silicon Valley that has only one table.

01:55:17.160 --> 01:55:18.120
Is this a real thing?

01:55:18.120 --> 01:55:19.480
I just wanted to ask you about that.

01:55:20.040 --> 01:55:24.200
Is that just like a metaphor you're using or is that an actual restaurant in

01:55:24.200 --> 01:55:24.960
Silicon Valley?

01:55:24.960 --> 01:55:26.520
It was, it was a metaphor, of course.

01:55:26.520 --> 01:55:26.760
Okay.

01:55:27.520 --> 01:55:29.200
I can imagine such a restaurant.

01:55:29.360 --> 01:55:34.680
So for people who don't then read the thing you should, you should, but it was a

01:55:35.640 --> 01:55:41.320
idea of a restaurant where there's only one table and you show up one at a time

01:55:41.520 --> 01:55:45.840
and they are prepared and actually looked it up and there is restaurants like this

01:55:45.920 --> 01:55:50.360
throughout the world and it just seems like a fascinating idea.

01:55:50.480 --> 01:55:52.840
You stand in line, you show up, there's one table.

01:55:53.640 --> 01:55:56.520
They, they ask you all kinds of questions.

01:55:56.520 --> 01:55:57.600
They cook just for you.

01:55:58.000 --> 01:55:58.640
That's fascinating.

01:55:58.640 --> 01:56:02.040
It sounds like you'd find places like that in Tokyo.

01:56:02.400 --> 01:56:06.560
It sounds like a very Japanese thing or in the Bay area, there are pop places

01:56:06.560 --> 01:56:08.240
that probably more or less work like that.

01:56:08.560 --> 01:56:10.200
I've never eaten at such a place.

01:56:10.440 --> 01:56:14.240
The fascinating thing is you propose as a fast food, this is all for a burger.

01:56:14.280 --> 01:56:21.800
It was one of my rare sort of more literary or poetic moments where I thought

01:56:21.840 --> 01:56:27.920
I'll just open with a crazy example to catch your attention and the rest is very

01:56:27.920 --> 01:56:34.560
dry stuff about locks and semaphores and how a semaphore is a generalization of a lock.

01:56:35.040 --> 01:56:38.480
Well, it was very poetic and well delivered and it actually made me wonder

01:56:38.480 --> 01:56:42.680
if it's real or not because you don't make that explicit and it feels like it

01:56:42.680 --> 01:56:46.400
could be true and in fact, I wouldn't be surprised if somebody like listens to

01:56:46.400 --> 01:56:49.280
this and knows exactly a restaurant like this in Silicon Valley.

01:56:49.760 --> 01:56:54.480
Anyway, can we step back and can you just talk about parallelism,

01:56:54.640 --> 01:56:58.880
concurrency, threading, asynchronous, all of these different terms?

01:56:59.480 --> 01:57:02.160
What is it sort of a high philosophical level?

01:57:02.280 --> 01:57:04.080
The, the fisherman is back in the boat.

01:57:04.680 --> 01:57:12.120
Well, the idea is if the fisherman has two fishing rods, since fishing is mostly

01:57:12.120 --> 01:57:16.920
a matter of waiting for a fish to nibble, well, it depends on how you do it actually.

01:57:16.920 --> 01:57:20.960
But if you had to, if, if you're doing the style of fishing where you sort

01:57:21.000 --> 01:57:26.480
of you, you throw it out and then you let it sit for a while until maybe you see a

01:57:26.480 --> 01:57:32.640
nibble, one fisherman can easily run two or three or four fishing rods.

01:57:32.880 --> 01:57:37.040
And so as long as you can afford the equipment, you can catch four times as

01:57:37.040 --> 01:57:41.680
many fish by a small investment in four fishing rods.

01:57:41.720 --> 01:57:47.000
And so since your time, you sort of say you have all Saturday to go fishing.

01:57:47.480 --> 01:57:52.440
If you can catch four times as much fish, you have a much higher productivity.

01:57:52.760 --> 01:57:55.280
And that's actually, I think how deep sea fishing is done.

01:57:55.280 --> 01:57:57.400
You could just have a rod and you put in the whole thing.

01:57:57.400 --> 01:57:58.400
You can have many rods.

01:57:59.080 --> 01:58:03.280
Uh, what is there an interesting difference between parallelism

01:58:03.280 --> 01:58:06.400
and concurrency and asynchronous?

01:58:06.480 --> 01:58:09.160
Is there one a subset of the other to you?

01:58:09.320 --> 01:58:10.680
Like, how do you think about these terms?

01:58:10.760 --> 01:58:16.040
In the computer world, there is a big difference when people are talking

01:58:16.040 --> 01:58:25.040
about parallelism, uh, like a parallel computer, that's usually really several

01:58:25.040 --> 01:58:32.200
complete CPUs that are sort of tied together and, and share something like

01:58:32.200 --> 01:58:41.120
memory or, uh, an IO bus, uh, concurrency can be a much more abstract concept

01:58:41.800 --> 01:58:48.600
where you have the illusion that things happen simultaneously.

01:58:48.600 --> 01:58:54.240
But what the computer actually does is it spends a little time running some

01:58:54.280 --> 01:58:58.040
this program for a while, and then it spends some time running that program

01:58:58.040 --> 01:59:01.880
for a while and then spending some time for the third program for a while.

01:59:02.560 --> 01:59:08.360
So parallelism is the reality and concurrency is part reality, part illusion.

01:59:08.360 --> 01:59:08.680
Yeah.

01:59:08.680 --> 01:59:14.800
Parallelism typically implies that there is multiple copies of the hardware.

01:59:15.720 --> 01:59:20.600
You write that implementing synchronization primitives is hard in that blog post.

01:59:20.720 --> 01:59:23.000
And you talk about locks and semaphores.

01:59:23.560 --> 01:59:26.720
Why is it hard to implement synchronization primitives?

01:59:27.040 --> 01:59:34.440
Because at the conscious level, our brains are not trained to, to sort

01:59:34.480 --> 01:59:38.880
of keep track of multiple things at the same time.

01:59:39.360 --> 01:59:44.080
Like, obviously you can walk and chew gum at the same time because they're

01:59:44.080 --> 01:59:51.160
both activities that require only a little bit of your conscious activity.

01:59:51.160 --> 01:59:57.040
But try balancing your checkbook and watching a murder mystery on TV.

01:59:57.840 --> 02:00:03.120
You'll mix up the digits or you'll miss an essential clue on in the TV show.

02:00:03.720 --> 02:00:08.560
So why does it matter that the programmer, the human is, is bad?

02:00:08.560 --> 02:00:13.720
Because the programmer is at least with the current state of the art is responsible

02:00:13.720 --> 02:00:23.000
for writing the code correctly and it's hard enough to keep track of a recipe

02:00:23.000 --> 02:00:30.200
that you just execute one step at a time, chop the carrots, then peel the

02:00:30.200 --> 02:00:32.920
potatoes, mix the icing.

02:00:33.760 --> 02:00:35.440
You need your whole brain.

02:00:35.600 --> 02:00:40.680
When you're, when you're reading a piece of code, what, what is going on?

02:00:40.720 --> 02:00:41.160
Okay.

02:00:41.160 --> 02:00:46.920
We're, we're, we're loading the number of mermaids in variable A and the

02:00:46.920 --> 02:00:49.080
number of mermen in variable B.

02:00:49.120 --> 02:00:51.840
And, uh, now we take the average or whatever.

02:00:53.040 --> 02:00:56.000
Uh, we're just jumping from metaphor to metaphor.

02:00:56.000 --> 02:00:56.520
I like it.

02:00:56.960 --> 02:00:58.640
You have to keep in your head.

02:00:58.640 --> 02:00:59.400
What is in A?

02:00:59.400 --> 02:01:00.440
What is in B?

02:01:00.680 --> 02:01:01.800
What is in C?

02:01:02.160 --> 02:01:07.360
Uh, hopefully you have better names and that is challenging enough.

02:01:08.040 --> 02:01:16.080
If you have two different pieces of code that are, are sort of being executed

02:01:17.120 --> 02:01:22.840
simultaneously, whether it's using the parallel or the concurrent approach.

02:01:23.640 --> 02:01:31.080
If like, A is the number of fishermen and B is the number of programmers, but

02:01:31.080 --> 02:01:35.080
in another part of the code, A is the number of mermaids and B is the number

02:01:35.080 --> 02:01:40.040
of merman and somehow that's the same variable.

02:01:40.040 --> 02:01:45.000
If you do it sequentially, if first you do your mermaid, merpeople computation,

02:01:45.000 --> 02:01:49.360
and then you do your people in the boat computation, it doesn't matter that

02:01:49.680 --> 02:01:53.880
the variables are called A and B and that is literally the same variable because

02:01:53.880 --> 02:01:59.120
you, you're done with one use of that variable, but when you mix them together,

02:01:59.400 --> 02:02:04.720
suddenly the number of merpeople replaces the number of fishermen and your

02:02:04.720 --> 02:02:07.600
computation goes dramatically wrong.

02:02:08.040 --> 02:02:12.880
And there's all kinds of ordering of operations that could result in

02:02:12.880 --> 02:02:14.320
the assignment of those variables.

02:02:14.320 --> 02:02:16.960
And so you have to anticipate all possible orderings.

02:02:17.040 --> 02:02:20.520
And you think you're smart and you'll put a lock around it.

02:02:21.040 --> 02:02:27.040
And in practice, in terms of bugs per line of per a thousand lines of code,

02:02:28.080 --> 02:02:30.560
this is an area where everything is worse.

02:02:30.760 --> 02:02:38.400
So a lock is a mechanism by which you forbid only one chef can

02:02:38.400 --> 02:02:42.040
access the oven at a time, something like that.

02:02:42.360 --> 02:02:44.960
And then semaphores allow you to do what?

02:02:45.040 --> 02:02:46.120
Multiple ovens.

02:02:46.360 --> 02:02:51.240
That's not a bad idea because if you're sort of, if you're preparing, if you're

02:02:51.240 --> 02:02:55.560
baking cakes and you have multiple people all baking cakes, but there's only

02:02:55.560 --> 02:03:00.200
one oven, then maybe you can tell that the oven is in use, but maybe it's

02:03:00.200 --> 02:03:07.440
preheating and so you have to, maybe you make a sign that says oven in use and

02:03:07.440 --> 02:03:11.320
you flip the sign over and it says oven is free when you're done baking your

02:03:11.320 --> 02:03:13.920
cake. That's a lock.

02:03:13.920 --> 02:03:19.520
That's sort of, and what do you do when you have two ovens or maybe you have

02:03:19.520 --> 02:03:25.320
10 ovens, you can put a separate sign on each oven or maybe you can sort of

02:03:25.320 --> 02:03:30.640
someone who comes in wants to see at a glance and maybe there's an electronic

02:03:30.640 --> 02:03:37.600
sign that says there are still five ovens available or maybe there are already

02:03:38.400 --> 02:03:40.880
three people waiting for an oven.

02:03:40.880 --> 02:03:46.880
So you can, if you see an oven that's not in use, it's already reserved for

02:03:46.880 --> 02:03:48.760
someone else who got in line first.

02:03:49.400 --> 02:03:53.160
And that's sort of what the restaurant metaphor was trying to explain.

02:03:53.680 --> 02:03:54.040
Yeah.

02:03:54.040 --> 02:03:59.960
And so you're now tasks, you're sitting as a designer of Python with a team of

02:03:59.960 --> 02:04:04.160
brilliant core developers and have to try to figure out to what degree can any

02:04:04.160 --> 02:04:06.320
of these ideas be integrated and not.

02:04:06.800 --> 02:04:12.920
So maybe this is a good time to ask, what is async IO and how has it evolved

02:04:12.920 --> 02:04:14.560
since Python 3.4?

02:04:15.720 --> 02:04:16.240
Wow.

02:04:16.280 --> 02:04:16.720
Yeah.

02:04:16.720 --> 02:04:25.240
So we had this really old library for, for doing things concurrently, especially

02:04:25.240 --> 02:04:32.040
things that had to do with IO and networking IO was especially a sort of a

02:04:32.040 --> 02:04:42.960
popular topic and in the Python standard library, we had a brief period where

02:04:42.960 --> 02:04:48.400
there was lots of development and I think it was late nineties, maybe early

02:04:48.400 --> 02:04:54.360
two thousands and like two little modules were added that were the state of the

02:04:54.360 --> 02:05:00.000
art of doing asynchronous IO or sort of non blocking a IO, which means that you

02:05:00.000 --> 02:05:05.320
can keep multiple network connections open and sort of service them all in

02:05:05.320 --> 02:05:07.640
parallel, like a typical web server does.

02:05:08.040 --> 02:05:09.760
So IO is input and outputs.

02:05:09.760 --> 02:05:14.560
You're writing either to the network from a network connection or reading and

02:05:14.560 --> 02:05:16.640
writing to a hard drive storage.

02:05:16.640 --> 02:05:17.560
Also possible.

02:05:17.720 --> 02:05:24.000
And you can do the ideas you could do to multiple while also doing computation.

02:05:24.920 --> 02:05:27.800
So running some code that does some fancy stuff.

02:05:28.080 --> 02:05:28.400
Yeah.

02:05:28.440 --> 02:05:33.840
Like when you're writing a web server, when a request comes in a user, the

02:05:33.840 --> 02:05:39.440
sort of needs to see a particular web page, you have to find that page, maybe

02:05:39.440 --> 02:05:43.640
in the database and format it properly and send it back to the client.

02:05:43.640 --> 02:05:48.800
And there's a lot of waiting, waiting for the database, waiting for the network.

02:05:48.800 --> 02:05:53.000
And so you can handle hundreds or thousands or millions of requests.

02:05:54.000 --> 02:05:55.640
Concurrently online machine.

02:05:55.640 --> 02:06:02.920
Anyway, ways of doing that in Python were kind of stagnated and I forget

02:06:02.920 --> 02:06:11.040
there might've been around 2012, 2014 when someone for the umpteenth time

02:06:11.040 --> 02:06:17.240
actually said these async chat and async core modules that you have in the

02:06:17.240 --> 02:06:21.960
standard library are not quite enough to solve my particular problem.

02:06:22.720 --> 02:06:25.120
Can we add one tiny little feature?

02:06:25.640 --> 02:06:30.720
And everybody said, no, that stuff is not too, you're not supposed to use that

02:06:30.720 --> 02:06:34.120
stuff, write your own using a third party library.

02:06:34.120 --> 02:06:37.760
And then everybody started the debate about what the right third party library

02:06:37.760 --> 02:06:47.320
was and somehow I, I felt that there was actually a queue for, well, maybe we

02:06:47.320 --> 02:06:54.560
need a better state of the art module in the standard library for, for multiplexing

02:06:54.560 --> 02:06:56.720
input output from different sources.

02:06:57.480 --> 02:07:00.480
You could say that it spiraled out of control a little bit.

02:07:00.520 --> 02:07:04.320
It was at the time, it was the largest Python enhancement

02:07:04.320 --> 02:07:06.200
proposal that was ever proposed.

02:07:07.000 --> 02:07:08.640
And you were deeply involved with that.

02:07:09.000 --> 02:07:11.680
At the time I was very much involved with that.

02:07:11.680 --> 02:07:13.480
I was like the lead architect.

02:07:14.320 --> 02:07:21.280
Uh, I ended up talking to people who had already developed serious third

02:07:21.280 --> 02:07:27.080
party libraries that did similar things and sort of taking ideas from them and

02:07:28.280 --> 02:07:30.800
getting their feedback on my design.

02:07:30.840 --> 02:07:34.160
And eventually we put it in the standard library.

02:07:34.160 --> 02:07:36.680
And after a few years, I got distracted.

02:07:36.680 --> 02:07:40.560
I think the thing, the big thing that distracted me was actually type annotations.

02:07:41.920 --> 02:07:47.120
But other people kept it alive and kicking and it's been quite successful

02:07:47.120 --> 02:07:51.040
actually in the world of Python web clients.

02:07:51.280 --> 02:07:55.680
So initially, what are some of the design challenges there in that debate for the

02:07:55.680 --> 02:07:58.440
PEP and what are some things that got rejected?

02:07:58.440 --> 02:08:00.640
What are some things that got accepted to stand out to you?

02:08:01.880 --> 02:08:07.720
There are a couple of different ways you can handle parallel IO and this happens

02:08:07.720 --> 02:08:11.800
sort of at an architectural level in operating systems as well.

02:08:11.800 --> 02:08:16.680
Like Windows prefers to do it one way and Unix prefers to do it the other way.

02:08:17.440 --> 02:08:23.440
You sort of, you have an object that represents a network endpoint, say a

02:08:23.440 --> 02:08:29.680
connection with a web browser that your client and say you're, you're, you're

02:08:29.680 --> 02:08:31.400
waiting for an incoming request.

02:08:31.960 --> 02:08:38.440
Two fundamental approaches are, okay, I'm waiting for an incoming request.

02:08:38.440 --> 02:08:39.880
I'm doing something else.

02:08:40.320 --> 02:08:44.640
Come wake me up or of course sort of come tell me when something interesting

02:08:44.640 --> 02:08:51.440
happened, like a packet came in on that network connection and the other paradigm

02:08:51.480 --> 02:08:59.000
is we're on a team of a whole bunch of people with maybe a little mind and we,

02:08:59.040 --> 02:09:01.960
we can only manage one web connection at a time.

02:09:01.960 --> 02:09:11.240
So I'm just sitting, looking at this, this web connection and I'm just blocked

02:09:11.560 --> 02:09:17.160
until something comes in and then I'm already waiting for it.

02:09:18.680 --> 02:09:23.600
I get, I get the data, I process the data and then I go back to the top and say,

02:09:23.600 --> 02:09:26.720
no, sort of I'm waiting for the next packet.

02:09:27.440 --> 02:09:29.120
Those are about the two paradigms.

02:09:29.160 --> 02:09:35.720
One is a paradigm where there is sort of notionally a thread of control, whether

02:09:35.720 --> 02:09:40.120
it's an actual operating system thread or more an abstraction in async IO, we

02:09:40.120 --> 02:09:47.760
call them tasks, but a task in async IO or a thread in other contexts is devoted

02:09:47.760 --> 02:09:54.600
to one thing and it has logic for all the stages, like when it's a web request,

02:09:54.640 --> 02:10:00.480
like first wait, wait for the first line of the web request, parse it because then

02:10:00.480 --> 02:10:07.960
you know if it's a get or a post or a put or whatever, or an error, then wait until

02:10:07.960 --> 02:10:12.400
you have a bunch of lines until there's a blank line, then parse that as headers

02:10:12.400 --> 02:10:18.760
and then interpret that and then wait for the rest of the data to come in if there

02:10:18.760 --> 02:10:23.880
is any more that you request, expect that sort of standard web stuff.

02:10:24.440 --> 02:10:29.240
And the other thing is, and there's always endless debate about which approach is

02:10:29.240 --> 02:10:34.480
more efficient and which approach is more error prone, where I just have a whole

02:10:34.480 --> 02:10:42.680
bunch of stacks in front of me and whenever a packet comes in, I sort of look at the

02:10:42.680 --> 02:10:46.600
number of the packet, that there's some number on the packet and I say, oh, that

02:10:46.600 --> 02:10:52.520
packet goes on this pile and then I can do a little bit and then sort of that pile

02:10:52.520 --> 02:10:59.560
provides my context and as soon as I'm done with the processing, I sort of, I can

02:10:59.560 --> 02:11:04.000
forget everything about what's going on because the next packet will come in from

02:11:04.000 --> 02:11:10.280
some random other client and it's that pile or this pile and every time a pile is

02:11:10.280 --> 02:11:16.160
maybe empty or full or whatever the criteria is, I can toss it away or use it for a new

02:11:16.160 --> 02:11:16.560
space.

02:11:16.560 --> 02:11:23.560
But several traditional third party libraries for asynchronous IO processing in

02:11:23.560 --> 02:11:29.600
Python shows the model of a callback and that's the idea where you have a bunch of

02:11:29.600 --> 02:11:34.480
different stacks of paper in front of you and every time someone gives you a piece,

02:11:34.760 --> 02:11:38.480
gives you a new sheet, you decide which stack it belongs to.

02:11:39.480 --> 02:11:49.600
And that leads to a certain style of spaghetti code that I find sort of aesthetically not

02:11:49.600 --> 02:11:56.080
pleasing and I was sort of never very successful and I had heard many stories about

02:11:56.080 --> 02:12:01.680
people who were also sort of complaining about that style of coding.

02:12:02.800 --> 02:12:08.000
It was very prevalent in JavaScript at the time, at least, because it was like how the

02:12:08.000 --> 02:12:11.280
JavaScript event loop basically works.

02:12:11.800 --> 02:12:19.880
And so I thought, well, the task based model where each task has a bunch of logic, we had

02:12:19.880 --> 02:12:25.880
mechanisms in the Python language that we could easily reuse for that.

02:12:25.960 --> 02:12:33.360
And I thought, I want to build a whole library for asynchronous networking IO and all the

02:12:33.360 --> 02:12:39.480
other things that may need to be done asynchronously based on that paradigm.

02:12:40.040 --> 02:12:45.680
And so I just chose a paradigm and tried to see how far I could get with that.

02:12:45.880 --> 02:12:48.320
And it turns out that it's a pretty good paradigm.

02:12:49.040 --> 02:12:55.640
So people enjoy that kind of paradigm programming for asynchronous IO relative to callbacks.

02:12:55.880 --> 02:12:58.640
OK, beautiful.

02:12:58.640 --> 02:13:05.440
So how does that all interplay with the infamous GIL, the Global Interpreter Lock?

02:13:06.840 --> 02:13:11.920
Maybe can you say what the GIL is and how does it dance beautifully with async IO?

02:13:13.240 --> 02:13:20.080
The Global Interpreter Lock solves the problem that Python originally was not written with

02:13:20.080 --> 02:13:24.920
either asynchronous or or parallelism in mind at all.

02:13:25.000 --> 02:13:26.760
There was no concurrency in the language.

02:13:26.760 --> 02:13:27.880
There was no parallelism.

02:13:27.880 --> 02:13:29.560
There were no threads.

02:13:30.280 --> 02:13:37.800
Only a small number of years into Python's initial development, all the new cool operating

02:13:37.800 --> 02:13:46.960
systems like SunOS and Silicon Graphics, IRIX and then eventually POSIX and Windows all

02:13:46.960 --> 02:13:53.280
came with threading libraries that let you do multiple things in parallel.

02:13:53.280 --> 02:14:00.360
And there is a certain sort of principle, which is the operating system handles the

02:14:00.360 --> 02:14:10.160
threads for you and the program can pretend that there are as many CPUs as there are

02:14:10.160 --> 02:14:11.400
threads in the program.

02:14:13.160 --> 02:14:17.120
And those CPUs work completely independently.

02:14:18.120 --> 02:14:25.080
And if you don't have enough CPUs, the operating system sort of simulates those extra CPUs.

02:14:25.080 --> 02:14:32.600
On the other hand, if you have enough CPUs, you can get a lot of work done by deploying

02:14:32.600 --> 02:14:34.040
those multiple CPUs.

02:14:34.040 --> 02:14:38.720
But Python wasn't written to to do that.

02:14:39.720 --> 02:14:51.800
And so as libraries for for multi-threading were added to C, but every operating system

02:14:51.800 --> 02:14:58.160
vendor was adding their own version of that, we thought and maybe we were wrong.

02:14:58.160 --> 02:15:02.840
But at the time, we thought, well, we quickly want to be able to support these multiple

02:15:02.880 --> 02:15:08.640
threads because they seemed at the time in the early 90s when they were new, at least

02:15:08.640 --> 02:15:13.760
to me, they seemed a cool, interesting programming paradigm.

02:15:13.760 --> 02:15:19.520
And one of the things that that Python, at least at the time, felt was nice about the

02:15:19.520 --> 02:15:27.680
language was that we could give a safe version of all kinds of cool new operating system

02:15:27.680 --> 02:15:30.200
toys to the Python programmer.

02:15:30.200 --> 02:15:39.280
Like, I remember one or two years before threading, I had spent some time adding networking

02:15:39.280 --> 02:15:47.160
sockets to Python and they were very literal translation of the networking sockets that

02:15:47.160 --> 02:15:49.040
were in the BSD operating system.

02:15:49.040 --> 02:15:51.400
So Unix BSD.

02:15:51.400 --> 02:15:57.160
But the nice thing was if you were using sockets from Python, then all the things you can do

02:15:57.160 --> 02:16:02.280
wrong with sockets in C would automatically give you a clear error message instead of

02:16:02.280 --> 02:16:06.480
just ending up with a malfunctioning hanging program.

02:16:06.480 --> 02:16:10.400
And so we thought, well, we'll do the same thing with threading.

02:16:10.400 --> 02:16:19.720
But we didn't really want to rewrite the interpreter to be thread safe because that that was was

02:16:19.720 --> 02:16:26.480
like there would be a very complex refactoring of all the interpreter code and all the runtime

02:16:26.560 --> 02:16:31.160
code because all the objects were written with the assumption that there is only one

02:16:31.160 --> 02:16:32.440
thread.

02:16:32.440 --> 02:16:40.160
And so we said, OK, well, we'll take our losses, we'll provide something that looks like threads.

02:16:40.160 --> 02:16:44.440
And as long as you only have a single CPU on your computer, which most computers at

02:16:44.440 --> 02:16:53.560
the time did, it feels just like threads because the whole idea of multiple threads in the

02:16:53.560 --> 02:16:59.800
OS was that even if your computer only had one CPU, you could still fire up at many threads

02:16:59.800 --> 02:17:01.000
as you wanted.

02:17:01.000 --> 02:17:06.240
Well, within reason, maybe 10 or 12, not 5000.

02:17:06.240 --> 02:17:17.040
And so we thought we had conquered the abstraction of threads pretty well because multi-core

02:17:17.040 --> 02:17:22.800
CPUs were not in most Python programmers' hands anyway.

02:17:22.800 --> 02:17:29.600
And then, of course, a couple of more iterations of Moore's law and computers getting faster.

02:17:29.600 --> 02:17:38.480
And at some point, the chip designers decided that they couldn't make the CPUs faster, but

02:17:38.480 --> 02:17:40.080
they could still make them smaller.

02:17:40.080 --> 02:17:43.720
And so they could put multiple CPUs on one chip.

02:17:43.720 --> 02:17:49.520
And suddenly there was all this pressure about do things in parallel.

02:17:49.640 --> 02:17:55.520
And that's where the solution we had in Python didn't work.

02:17:55.520 --> 02:18:01.880
And that's sort of the moment that the GIL became infamous.

02:18:01.880 --> 02:18:09.600
Because the GIL was the solution we used to sort of take this single interpreter and share

02:18:09.600 --> 02:18:15.060
it between all the different operating system threads that you could create.

02:18:15.060 --> 02:18:21.780
And so as long as the hardware physically only had one CPU, that was all fine.

02:18:21.780 --> 02:18:27.940
And then as hardware vendors were suddenly telling us all, oh, you got to paralyze.

02:18:27.940 --> 02:18:30.380
Everything's got to be paralyzed.

02:18:30.380 --> 02:18:36.180
People started saying, oh, but we can use multiple threads in Python.

02:18:36.180 --> 02:18:41.060
And then they discovered, oh, but actually all threads run on a single core.

02:18:41.060 --> 02:18:42.060
Yeah.

02:18:42.540 --> 02:18:48.380
I mean, is there a way, is there ideas in the future to remove the global interpreter

02:18:48.380 --> 02:18:56.740
log GIL, like maybe multiple sub-interpreters, some tricky interpreters on top of interpreters

02:18:56.740 --> 02:18:57.740
kind of thing?

02:18:57.740 --> 02:19:04.140
Yeah, there are a couple of possible futures there.

02:19:04.140 --> 02:19:11.620
The most likely future is that we'll get multiple sub-interpreters, which each run a completely

02:19:11.620 --> 02:19:22.020
independent Python program, but there's still some benefit of sort of faster communication

02:19:22.020 --> 02:19:25.180
between those programs.

02:19:25.180 --> 02:19:31.580
But it's also managing for you this running a multiple Python programs, so it's hidden

02:19:31.580 --> 02:19:33.720
from you, right?

02:19:33.720 --> 02:19:39.100
It's hidden from you, but you have to spend more time communicating between those programs

02:19:39.100 --> 02:19:48.940
because the attractive thing about the multi-threaded model is that the threads can share objects.

02:19:48.940 --> 02:19:54.220
At the same time, that's also the downfall of the multi-threaded programming model because

02:19:54.220 --> 02:20:03.760
when you do share objects and you didn't necessarily intend to share them or there were aspects

02:20:03.760 --> 02:20:13.760
of those objects that were not reusable, you get all kinds of concurrency bugs.

02:20:13.760 --> 02:20:19.800
The reason I wrote that little blog post about semaphores was that concurrency bugs are just

02:20:19.800 --> 02:20:21.480
harder.

02:20:21.480 --> 02:20:30.360
It would be nice if Python had no global interpreter log and it had the so-called free threading,

02:20:30.360 --> 02:20:35.800
but it would also cause a lot more software bugs.

02:20:35.800 --> 02:20:44.200
The interesting thing is that there is still a possible future where we could experiment

02:20:44.200 --> 02:20:53.200
at least with that because there is a guy working for Facebook who has developed a fork

02:20:53.960 --> 02:21:03.080
Python that he called the no-gil interpreter where he removed the gil and made a whole

02:21:03.080 --> 02:21:11.600
bunch of optimizations so that the single-threaded case doesn't run too much slower and multi-threaded

02:21:11.600 --> 02:21:19.160
case will actually use all the cores that you have.

02:21:19.160 --> 02:21:28.280
That would be an interesting possibility if we would be willing as Python core developers

02:21:28.280 --> 02:21:38.400
to actually maintain that code indefinitely and if we're willing to put up with the additional

02:21:38.400 --> 02:21:45.760
complexity of the interpreter and the additional overhead for the single-threaded case.

02:21:45.920 --> 02:21:58.040
I'm personally not convinced that there are enough people needing the speed of multiple

02:21:58.040 --> 02:22:07.240
threads with their Python programs that it's worth to take that performance hit and that

02:22:07.240 --> 02:22:09.680
complexity hit.

02:22:09.680 --> 02:22:18.240
I feel that the gil actually is a pretty nice Goldilocks point between no threads and all

02:22:18.240 --> 02:22:24.240
threads all the time, but not everybody agrees on that, so that is definitely a possible

02:22:24.240 --> 02:22:25.240
future.

02:22:25.240 --> 02:22:32.680
The sub-interpreters look like a fairly safe bet for 3.12, so say a year from now.

02:22:32.680 --> 02:22:36.960
The goal is to do a new version every year for Python.

02:22:37.040 --> 02:22:42.560
Let me ask you perhaps a fun question, but there's a philosophy to it.

02:22:42.560 --> 02:22:46.400
Will there ever be a Python 4.0?

02:22:46.400 --> 02:22:56.520
Before you say it's currently a joke and probably not, we're gonna go to 3.99 or 3.999.

02:22:56.520 --> 02:23:06.160
Can you imagine possible features that Python 4.0 might have that would necessitate the

02:23:06.160 --> 02:23:15.440
creation of the new 4.0, given the amount of pain and joy, suffering and triumph that

02:23:15.440 --> 02:23:20.240
was involved in the move between version two and version three?

02:23:21.200 --> 02:23:34.000
Yeah, well, as a community and as a core development team, we have a large amount of painful memories

02:23:34.000 --> 02:23:43.760
about the Python 3 transition, which is one reason that everybody is happy that we've

02:23:43.760 --> 02:23:51.800
decided there's not going to be a 4.0, at least not anytime soon. And if there is going to be one,

02:23:51.800 --> 02:24:00.200
we'll sort of plan the transition very differently. Because clearly we underestimated the pain the

02:24:00.200 --> 02:24:10.600
transition caused for our users in the Python 3 case. And had we known we could have sort of

02:24:10.640 --> 02:24:19.120
designed Python 3 somewhat differently without making it any worse. We just thought that we

02:24:19.120 --> 02:24:27.600
had a good plan, but we underestimated what sort of the users were capable of when it comes to that

02:24:27.600 --> 02:24:34.960
kind of transition. By the way, I think we talked way before, like a year and a half before the

02:24:35.360 --> 02:24:44.560
Python 2 officially end of life. What was your memory of the end of life? Did you shed a tear

02:24:44.560 --> 02:24:51.360
on January 1st, 2020? Were you standing alone? Everyone on the core team had basically moved

02:24:51.360 --> 02:25:03.840
on years before. It was a little symbolic moment to signal to the remaining users that

02:25:05.920 --> 02:25:12.400
there was no longer going to be any new releases or support for Python 2.7.

02:25:14.000 --> 02:25:17.440
Did you shed a single tear while looking out over the horizon?

02:25:18.480 --> 02:25:23.920
I'm not a very poetic person, and I don't shed tears like that, but no.

02:25:26.240 --> 02:25:34.000
Now we actually had planned a party, but the party was planned for the US Python conference

02:25:34.320 --> 02:25:37.600
that year, which never happened, of course, because of the pandemic.

02:25:40.080 --> 02:25:47.680
The conference was going to be, I think, late April that year. That was a very difficult

02:25:47.680 --> 02:25:55.040
decision to cancel it, but they did. Anyway, if we're going to have a Python 4, we're going

02:25:55.040 --> 02:26:03.280
to have to have both a different reason for having that and a different process for managing the

02:26:03.280 --> 02:26:11.200
transition. Can you imagine a possible process? I think you're implying that if there is a 4.0,

02:26:11.200 --> 02:26:20.640
in some ways it would break back compatibility. Well, so here is a concrete thought I've had,

02:26:20.640 --> 02:26:26.000
and I'm not unique, but not everyone agrees with this, so this is definitely a personal opinion.

02:26:26.160 --> 02:26:32.240
If we were to try something like that Nogil Python,

02:26:35.680 --> 02:26:43.680
my expectation is that it would feel just different enough,

02:26:45.680 --> 02:26:53.680
at least for the part of the Python ecosystem that is heavily based on C extensions,

02:26:54.640 --> 02:27:02.720
and that is like the entire machine learning, data science, scientific Python world is all

02:27:02.720 --> 02:27:15.280
based on C extensions for Python. Those people would likely feel the pain the most because

02:27:16.880 --> 02:27:22.640
even if we don't change anything about the syntax of the language and the semantics of

02:27:22.640 --> 02:27:28.800
the language when you're writing Python code, we could even say, suppose that after Python, say,

02:27:28.800 --> 02:27:35.520
3.19 instead of 3.20, we'll have 4.0. Suppose that's the time when we

02:27:36.400 --> 02:27:46.560
flip the switch to 4.0 will not have a GIL. Imagine it was like that. I would probably say

02:27:46.960 --> 02:27:55.680
that particular year, the release that we name 4.0 will be syntactically, it will not have any new

02:27:55.680 --> 02:28:02.000
syntactical features, no new modules in the standard library, no new built-in functions.

02:28:03.440 --> 02:28:12.400
Everything will be, at the Python level, will be purely compatible with Python 3.19. However,

02:28:12.560 --> 02:28:21.600
however, extension modules will have to make a change. They will have to be recompiled.

02:28:21.600 --> 02:28:26.320
They will not have the same binary interface.

02:28:29.200 --> 02:28:38.880
The semantics and APIs for some things that are frequently accessed by C extensions will be

02:28:38.880 --> 02:28:48.320
different. For a pure Python user, 4.0 would be a breeze, except that there are very few

02:28:48.320 --> 02:28:54.640
pure Python users left because everybody who is using Python for something significant is using

02:28:55.440 --> 02:29:02.000
third-party extensions. There are several hundreds of thousands of third-party extensions on

02:29:02.960 --> 02:29:11.840
the PyPI service. I'm not saying they're all good, but there is a large list of extensions

02:29:11.840 --> 02:29:18.160
that would have to do work. Some of those extensions are currently already low on

02:29:18.160 --> 02:29:26.720
maintainers and they're struggling to keep afloat. There you can give a huge heads up to them if you

02:29:26.880 --> 02:29:32.560
go to 4.0 to really keep developing it. We'd probably have to do something like

02:29:34.960 --> 02:29:41.200
several years before, who knows, maybe five years earlier, like 3.15, we would have to say,

02:29:42.000 --> 02:29:47.120
and I'm just making the specific numbers up, but at some point we'd have to say

02:29:47.120 --> 02:29:54.880
the Nogil Python could be an option. It might be a compile time option.

02:29:57.120 --> 02:30:04.240
If you want to use Nogil Python, you have to recompile Python from source for your platform

02:30:04.240 --> 02:30:10.720
using your tool set. All you have to do is change one configuration variable and then you just run

02:30:10.720 --> 02:30:19.360
make or configure and make and it will build it for you. But now you also have to use the

02:30:19.360 --> 02:30:26.560
Nogil compatible versions of all extension modules you want to use. As long as many

02:30:26.560 --> 02:30:34.880
extension modules don't have fully functional variants that work in the Nogil world,

02:30:35.840 --> 02:30:42.640
that's not a very practical thing for Python users, but it would allow extension developers

02:30:43.840 --> 02:30:50.960
to test the waters, see what they need to syntactically to be able to compile at all.

02:30:50.960 --> 02:30:58.080
Maybe they're using functions that are defined by the Python 3 runtime that won't be in the Python

02:30:58.080 --> 02:31:02.720
4 runtime. Those functions will not work. They'll have to find an alternative,

02:31:04.320 --> 02:31:11.040
but they can experiment with that and write test applications. That would be a way to transition

02:31:11.040 --> 02:31:20.960
and that could be a series of releases where the Python 4 is more and more imminent. We

02:31:21.920 --> 02:31:28.240
have supported more and more third-party extension modules to have solid support

02:31:28.240 --> 02:31:40.960
that works for Nogil Python for that new API. Python 4.0 is the official moment that the

02:31:40.960 --> 02:31:49.760
mayor comes out and cuts the ribbon and now the Nogil mode is the default and maybe the only mode

02:31:49.760 --> 02:31:59.440
there is. The internet wants to know from Reddit. It's a small and fun question. There's many fun

02:31:59.440 --> 02:32:10.160
questions, but out of the PyPI packages, do you have ones you like? In your opinion,

02:32:10.160 --> 02:32:15.120
are there must-have PyPI libraries or ones you use all the time constantly?

02:32:15.120 --> 02:32:20.720
Oh my. I should really have a standard answer for that question, but

02:32:21.920 --> 02:32:28.640
a positive standard answer. My current standard answer is that I'm not a big user of third-party

02:32:28.640 --> 02:32:36.160
packages. When I write Python code, I'm usually developing some tooling around building Python

02:32:36.160 --> 02:32:45.520
itself. The last thing we want is dependencies on third-party packages. I tend to just use the

02:32:45.520 --> 02:32:52.400
standard library. That's where your focus is. That's where your mind is. Do you keep an eye

02:32:52.400 --> 02:32:58.240
on what's out there to understand where the standard library could be moving, should be moving?

02:32:58.240 --> 02:33:02.560
It's a good kind of landscape of what's missing from the standard library.

02:33:02.560 --> 02:33:06.640
Well, usually when something's missing from the standard library nowadays,

02:33:09.840 --> 02:33:19.600
it is a relatively new idea and there is a third-party implementation or maybe possibly

02:33:19.600 --> 02:33:26.640
multiple third-party implementations, but they evolve at a much higher rate than they could when

02:33:26.640 --> 02:33:36.560
they're in the standard library. It would be a big reduction in activity to incorporate things

02:33:36.560 --> 02:33:42.160
like that in the standard library. I like that there is a lively package ecosystem and that

02:33:43.280 --> 02:33:47.920
recent trends in the standard library are actually that we're doing the occasional

02:33:47.920 --> 02:34:00.720
spring cleaning where we're choosing some modules that have not had a lot of change

02:34:00.720 --> 02:34:08.880
in a long time and that maybe would be better off not existing at all at this point,

02:34:08.880 --> 02:34:15.520
because there might be a better third-party alternative anyway. We're sort of slowly

02:34:15.520 --> 02:34:23.760
removing those. Often those are things that I spiked somewhere in 1992 or 1993.

02:34:25.200 --> 02:34:32.880
If you look through the commit history, it's very sad. All cosmetic changes like changes

02:34:32.880 --> 02:34:38.880
in the indentation style or the name of this other standard library module got changed.

02:34:39.680 --> 02:34:46.000
It's like nothing of any substance. The API is identical to what it was 20 years ago.

02:34:48.400 --> 02:34:54.800
Speaking of packages, they have a lot of impact on a lot of people's lives. Does it make sense

02:34:54.800 --> 02:34:59.920
to you why Python has become the primary, the dominant language for the machine learning

02:34:59.920 --> 02:35:07.040
community? Packages like PyTorch, TensorFlow, SecondLearn, and even the lower-level stuff like

02:35:07.040 --> 02:35:13.920
NumPy, SciPy, Pandas, Matplotlib with visualization. Does it make sense to you why it

02:35:16.480 --> 02:35:20.240
permeated the entire data science, machine learning, AI community?

02:35:22.640 --> 02:35:28.640
Part of it is an effect that's as simple as we're all driving on the right side of the road.

02:35:28.640 --> 02:35:43.440
Right. It's compatibility. Part of it is not quite as fundamental as driving on the

02:35:43.440 --> 02:35:48.240
right side of the road, which you have to do for safety reasons. You have to agree on something.

02:35:50.000 --> 02:35:54.800
They could have picked JavaScript or Perl. There was a time in the early 2000s that it

02:35:54.800 --> 02:36:02.560
really looked like Perl was going to dominate like biosciences because DNA search was all based on

02:36:02.560 --> 02:36:07.600
regular expressions and Perl has the fastest and most comprehensive regular expression engine,

02:36:07.600 --> 02:36:16.640
still does. I spent quite a long time with Perl. That was another letting go of this kind of data

02:36:16.640 --> 02:36:27.040
processing system. The reasons why Python became the lingua franca of scientific code and

02:36:29.760 --> 02:36:36.960
machine learning in particular and data science, it really had a lot to do with

02:36:38.320 --> 02:36:46.400
anything was better than C or C++. Recently, a guy who worked at Lawrence Livermore National

02:36:46.400 --> 02:36:58.080
Laboratories in the computing division wrote me his memoirs and he had his own view of

02:36:58.720 --> 02:37:04.400
how he helped something he called computational steering into existence.

02:37:06.960 --> 02:37:12.480
This was the idea that you take libraries that in his days were written in Fortran

02:37:13.040 --> 02:37:23.120
that solved universal mathematical problems. Those libraries still work, but the scientists

02:37:23.120 --> 02:37:32.160
that use the libraries use them to solve continuously different specific applications

02:37:32.160 --> 02:37:42.000
and answer different questions. Those poor scientists were required to use, say, Fortran

02:37:42.000 --> 02:37:48.800
because Fortran was the language that the library was written in and then the scientists would have

02:37:48.800 --> 02:37:58.640
to write an application that uses the library to solve a particular equation or answer a set

02:37:58.640 --> 02:38:08.400
of questions. The same for C++ because there's interoperability. The dusty decks are written

02:38:08.400 --> 02:38:18.240
either in C++ or Fortran. Paul Dubois was one of the people who I think in the mid-90s

02:38:19.520 --> 02:38:31.360
saw that you needed a higher level language for the scientists to tie together the fundamental

02:38:31.360 --> 02:38:42.320
mathematical algorithms of linear algebra and other stuff. Gradually, some libraries started

02:38:42.320 --> 02:38:51.520
appearing that did very fundamental stuff with arrays of numbers in Python. When I first created

02:38:51.520 --> 02:38:56.800
Python, I was not expecting it to be used for arrays of numbers much. I thought that was like

02:38:56.800 --> 02:39:05.200
an outdated data type and everything was like objects and strings. Python was good and fast

02:39:05.200 --> 02:39:11.280
at string manipulation and objects, obviously, but arrays of numbers were not very efficient.

02:39:11.280 --> 02:39:14.960
The multi-dimensional arrays didn't even exist in the language at all.

02:39:17.840 --> 02:39:26.080
There were people who realized that Python had extensibility that was flexible enough that they

02:39:26.080 --> 02:39:34.560
could write third-party packages that did support large arrays of numbers and operations on them

02:39:34.560 --> 02:39:43.840
very efficiently. Somehow, they got a foothold through different parts of the scientific

02:39:43.840 --> 02:39:49.440
community. I remember that the Hubble Space Telescope people in Baltimore were somehow

02:39:49.440 --> 02:39:58.880
big Python fans in the late 90s. At various points, small improvements were made and more

02:39:58.880 --> 02:40:09.200
people got in touch with using Python to derive these libraries of interesting algorithms.

02:40:11.040 --> 02:40:15.440
Once you have a bunch of scientists who are working on similar problems, say they're all

02:40:15.440 --> 02:40:21.440
working on data that comes in from the Hubble Space Telescope, but they're looking at different

02:40:21.440 --> 02:40:27.200
things. Some are looking at stars in this galaxy, others are looking at galaxies. The math is

02:40:27.200 --> 02:40:37.440
completely different, but the underlying libraries are still the same. They exchange code. They say,

02:40:37.440 --> 02:40:42.960
well, I wrote this Python program or I wrote a Python library to solve this class of problems.

02:40:43.920 --> 02:40:50.080
And the other guys either say, oh, I can use that library too, or if you make a few changes,

02:40:50.080 --> 02:40:58.320
I can use that library too. Why start from scratch in Perl or JavaScript where there's not that

02:40:58.320 --> 02:41:05.840
infrastructure for arrays of numbers yet? In Python, you have it. And so more and more

02:41:05.840 --> 02:41:15.440
scientists at different places doing different work discovered Python. And then people who had

02:41:15.440 --> 02:41:24.080
an idea for an important new fundamental library decided, oh, Python is actually already known to

02:41:24.080 --> 02:41:31.440
our users. So let's use Python as the user interface. I imagine at least that's how

02:41:31.440 --> 02:41:37.280
TensorFlow ended up with Python as the user interface. Right. But with TensorFlow,

02:41:37.840 --> 02:41:44.960
there's a deeper history of what the community is. It's not just like what packages it needs,

02:41:44.960 --> 02:41:51.520
it's like what the community leans on for programming language. Because TensorFlow had a

02:41:51.520 --> 02:41:58.080
prior library that was internal to Google, but there was also competing machine learning

02:41:58.160 --> 02:42:03.760
frameworks like Theano, Cafe that were in Python. There was some Scala,

02:42:05.520 --> 02:42:11.280
some other languages, but Python was really dominating it. And it's interesting because

02:42:11.920 --> 02:42:17.920
there's other languages from the engineering space like Matlab that a lot of people used,

02:42:18.560 --> 02:42:25.920
but different design choices by the company, by the core developers led to it not spreading.

02:42:25.920 --> 02:42:31.440
And one of the choices with Matlab by MathWorks is to not make it open source,

02:42:31.440 --> 02:42:37.120
right? Or not having people pay. It was a very expensive product. And so

02:42:38.160 --> 02:42:44.080
universities especially disliked it because it was a price per seat. I remember hearing.

02:42:45.040 --> 02:42:52.160
Yeah. But I think that's not why it failed or failed to spread. I think the universities

02:42:52.160 --> 02:42:58.240
didn't like it, but they would still pay for it. The thing is it didn't feed into that GitHub

02:42:58.240 --> 02:43:08.000
open source packages culture. And that's somehow a precondition for viral spreading,

02:43:08.000 --> 02:43:13.760
the hacker culture, like the tinkerer culture. With Python, it feels like you can build a package

02:43:13.760 --> 02:43:18.880
from scratch or solve a particular problem and get excited about sharing that package with others.

02:43:18.880 --> 02:43:25.040
And that creates an excitement about a language. I tend to like Python's approach to open source

02:43:25.040 --> 02:43:36.240
in particular, because it's almost egalitarian. There's little hierarchy. There's obviously some

02:43:36.240 --> 02:43:41.680
because you all need to decide whether you drive on the left or the right side of the road sometimes.

02:43:42.640 --> 02:43:49.040
But there is a lot of access for people with little power. You don't have to work for a big

02:43:49.040 --> 02:43:58.160
tech company to make a difference in the Python world. We have affordable events that really care

02:43:58.160 --> 02:44:08.480
about community and support people. And sort of the community is like a big deal at our conferences

02:44:08.480 --> 02:44:19.520
and in the PSF. When the PSF funds events, it's always about growing the community. The PSF funds

02:44:19.520 --> 02:44:29.280
very little development. They do some, but most of the money that the PSF forks out

02:44:29.280 --> 02:44:34.400
is to community fostering things.

02:44:35.440 --> 02:44:41.840
So speaking of egalitarian, last time we talked four years ago, it was just after you stepped down

02:44:41.840 --> 02:44:49.440
from your role as the benevolent dictator for life, BDFL. Looking back, what are your insights

02:44:49.440 --> 02:44:56.160
and lessons you learned from that experience about Python developer community, about human nature,

02:44:56.160 --> 02:45:06.960
about human civilization, life itself? Oh, my. I probably held on to the position too long.

02:45:08.640 --> 02:45:19.360
I remember being just extremely stressed for a long time. And it wasn't very clear to me

02:45:20.320 --> 02:45:34.080
what was leading, what was causing the stress. And looking back, I should have sort of relinquished

02:45:34.720 --> 02:45:43.280
my central role as BDFL sooner. What were the pros and cons of the BDFL role? What were the

02:45:43.840 --> 02:45:47.840
you not relinquishing it? What are the benefits of that for the community?

02:45:48.400 --> 02:45:54.880
And what are the drawbacks? Well, the benefits for the community would be things like

02:45:58.800 --> 02:46:10.880
clarity of vision and sort of a clear direction. Because I had certain ideas in mind when I

02:46:10.880 --> 02:46:19.840
created Python. And while I sort of let myself be influenced by many other ideas as Python evolved

02:46:19.840 --> 02:46:30.560
and became more successful and more complex and more used, I also stuck to certain principles.

02:46:30.560 --> 02:46:37.760
And still hard to say what are Python's core principles. But the fact that I was

02:46:38.720 --> 02:46:46.480
playing that role and sort of always very active grew the community in a certain way.

02:46:47.680 --> 02:46:55.440
It modeled to the community how to think about how to solve a certain problem. Well,

02:46:56.480 --> 02:47:00.320
that was a source of stress, but it was also beneficial. It was a source of stress for me

02:47:00.320 --> 02:47:08.640
personally, but it was beneficial for the community because people sort of over time

02:47:08.640 --> 02:47:18.400
had learned how I was thinking and could predict how I would decide about a particular issue.

02:47:18.400 --> 02:47:25.760
And not always perfectly, of course, but there wasn't a lot of joking around like this year,

02:47:25.760 --> 02:47:31.040
we're all, but this year the Democrats are in power and we're doing these kinds of things.

02:47:31.040 --> 02:47:35.520
And now the Republicans are in power and they roll all that back and do those kinds of things.

02:47:36.480 --> 02:47:44.960
There is a clear, fairly straight path ahead. And so fortunately, the successor structure

02:47:44.960 --> 02:47:52.960
with the steering council has sort of found a similar way of leading the community

02:47:53.920 --> 02:48:00.800
in a fairly steady direction without stagnating. And for me personally, it's more fun because

02:48:01.760 --> 02:48:07.680
there are things I can just ignore. Yeah. Oh yeah. There's a bug in multiprocessing.

02:48:07.680 --> 02:48:10.800
Let someone else decide whether that's important to solve or not.

02:48:13.040 --> 02:48:18.560
I'll stick to typing in the async IO and the faster interpreter.

02:48:18.560 --> 02:48:20.720
Yeah. It allows you to focus a little bit more.

02:48:20.720 --> 02:48:26.800
Yeah. What are interesting differences in culture, if you can comment on between Google,

02:48:26.800 --> 02:48:32.160
Dropbox and Microsoft from a Python programming perspective, all places you've been to, the

02:48:32.160 --> 02:48:40.000
positive. Is there a difference or is it just about people and there's great people everywhere

02:48:40.000 --> 02:48:46.080
or is there a culture differences? So Dropbox is much smaller than the other

02:48:46.080 --> 02:48:55.280
two in your list. So that is a big difference. The set of products they provide is narrower,

02:48:55.280 --> 02:49:02.400
so they're more focused. Yeah. And Dropbox, at least during the time I was there,

02:49:03.680 --> 02:49:11.760
had the tendency of making a big plan, putting the whole company behind that plan for a year

02:49:12.320 --> 02:49:19.840
and then evaluate and then suddenly find that everything was wrong about the plan

02:49:19.840 --> 02:49:27.440
and then they had to do something completely different. So there was like the annual engineering

02:49:27.440 --> 02:49:33.680
reorg was sort of an unpleasant tradition at Dropbox because like, oh, there's a new VP of

02:49:33.680 --> 02:49:39.680
engineering and so now all the directors are being reshuffled and this guy was in charge of

02:49:40.080 --> 02:49:46.640
of infrastructure one year and the next year he was made in charge of, I don't know, product

02:49:46.640 --> 02:49:52.080
development. It's fascinating because like you don't think about these companies internally,

02:49:52.080 --> 02:49:58.240
but Dropbox to me from the very beginning was one of my favorite services. There's certain

02:49:58.240 --> 02:50:04.320
programs and online services that make me happy, make me more efficient and all that kind of stuff.

02:50:04.320 --> 02:50:09.520
But one of the powers of those kinds of services, they disappear. You're not supposed to think

02:50:09.520 --> 02:50:14.560
about how it all works, but it's incredible to me that you can sync stuff effortlessly

02:50:15.680 --> 02:50:22.720
across so many machines so quickly and like don't have to worry about conflicts. They take care of

02:50:22.720 --> 02:50:28.000
the, you know, as a person that comes from version repositories and all that kind of stuff or merge

02:50:28.560 --> 02:50:34.000
is super difficult and just keeping different versions of different files is very tricky.

02:50:34.000 --> 02:50:38.480
The fact that they could take care of that is just, I don't know, the engineering behind

02:50:38.480 --> 02:50:42.800
the scenes must be super difficult, both on the computer infrastructure and the software.

02:50:43.360 --> 02:50:51.920
A lot of internal sort of hand wringing about things like that, but the product itself always

02:50:51.920 --> 02:50:57.600
worked very smoothly. Yeah, well, there's probably a lot of lessons to that. You can have a lot of

02:50:57.600 --> 02:51:03.280
turmoil inside on the engineering side, but if the product is good, the product is good and

02:51:03.280 --> 02:51:10.080
maybe don't mess with that either. When it's good, it's like with Google, focus on the search and the

02:51:10.080 --> 02:51:17.680
ads. And the money will come. Yeah. And make sure that's done extremely well and don't forget what

02:51:17.680 --> 02:51:24.400
you do extremely well. In what ways do you provide value and happiness to the world? Make sure you

02:51:24.400 --> 02:51:30.960
do that well. Is there something else to say about Google and Microsoft? Microsoft has had a very

02:51:30.960 --> 02:51:38.880
fascinating shift recently with the new CEO, with recent CEO, with purchasing GitHub,

02:51:39.840 --> 02:51:44.480
embracing open source culture, embracing the developer culture. It's pretty interesting to see.

02:51:44.480 --> 02:51:50.880
That's like why I joined Microsoft. I mean, after retiring and thinking that I would

02:51:51.600 --> 02:51:55.360
stay retired for the rest of my life, which of course was a ridiculous thought,

02:51:56.160 --> 02:52:03.600
but I was done working for a bit. And then the pandemic made me realize that work can also

02:52:03.600 --> 02:52:08.640
provide a source of fulfillment, keep you out of trouble.

02:52:11.120 --> 02:52:18.800
Microsoft is a very interesting company because it has this incredible, very long and

02:52:19.440 --> 02:52:28.800
varied history and this amazing catalog of products that many of which also date way back.

02:52:29.760 --> 02:52:38.800
I mean, I've been talking to a bunch of Excel people lately and Excel is like 35 years old

02:52:39.760 --> 02:52:46.000
and they can still read spreadsheets that they might find on an old floppy drive.

02:52:48.800 --> 02:52:52.000
Yeah, there's so many incredible tools through the years.

02:52:53.200 --> 02:53:01.280
Excel, one of the great shames of my life is that I've never learned how to use Excel well.

02:53:01.920 --> 02:53:07.760
I mean, it just always felt like so many features are there. It's similar with IDE's like PyCharm.

02:53:08.560 --> 02:53:14.240
It feels like I converge quickly to the dumbest way to use a thing to get the job done when

02:53:14.240 --> 02:53:20.720
clearly there's so much more power in your fingertips. I do think there's probably expert

02:53:20.720 --> 02:53:28.640
users of Excel. Excel is a cash cow actually. Oh, it actually brings in money. Oh, yeah.

02:53:28.640 --> 02:53:35.680
A lot of the engineering sort of, if you look deep inside Excel, there's some very good

02:53:35.680 --> 02:53:42.800
engineering, very impressive stuff. Okay, now I need to definitely learn Excel a little better.

02:53:42.800 --> 02:53:47.840
I had issues because I'm a keyboard person, so I had issues coming up with shortcuts.

02:53:47.840 --> 02:53:53.360
Microsoft sometimes, it's changed over the years, but sometimes they kind of want to make things

02:53:53.360 --> 02:54:01.920
easier for you on the surface and therefore make it harder for people that like to have shortcuts

02:54:01.920 --> 02:54:07.600
and all that kind of stuff to optimize their workflow. Now, people are probably yelling at me,

02:54:07.600 --> 02:54:10.960
it's like no, Excel probably has a lot of ways to optimize the workflow.

02:54:10.960 --> 02:54:17.280
In fact, I keep discovering that there are many features in Excel that only exists at keyboard

02:54:17.280 --> 02:54:23.520
shortcuts. Yeah, that's the sense I have. And now like I'm embarrassed that it's just,

02:54:23.520 --> 02:54:31.360
you just have to know what they are. That's like, there's no logic or reason to the assignment of

02:54:31.440 --> 02:54:36.000
the keyboard shortcuts because they go back even longer than 35 years.

02:54:37.040 --> 02:54:43.360
Can you maybe comment about Sachin Adela and how hard it is for a CEO to sort of pivot a company

02:54:43.360 --> 02:54:47.040
towards open source or developer culture? Is there something you could see about like,

02:54:48.080 --> 02:54:53.440
what's the role of leadership in such a pivot and definition of a new vision?

02:54:54.000 --> 02:55:03.440
I've never met him, but I hear he's just a really sharp thinker,

02:55:04.960 --> 02:55:12.640
but he also has an incredible business sense. He took the organization that had very solid pieces,

02:55:12.640 --> 02:55:22.320
but that was also struggling with all sorts of shameful things, especially the Steve Ballmer

02:55:22.320 --> 02:55:29.440
time. I imagine in part through his personal charm and thinking, and of course the great

02:55:29.440 --> 02:55:36.240
trust that the rest of the leadership has in him, he managed to really turn the company around and

02:55:38.640 --> 02:55:46.240
change it from openly hostile to open source to actively embracing open source.

02:55:46.880 --> 02:55:52.560
And that doesn't mean that suddenly Excel is going to go open source, but that means that there's

02:55:52.560 --> 02:55:59.360
room for a product like VS Code, which is open source. Yeah, it's fascinating. It gives me faith

02:55:59.360 --> 02:56:06.320
that large companies with good leadership can grow, can expand, can change and pivot and so on,

02:56:06.320 --> 02:56:12.880
develop because it gets harder and harder as the company gets large. You wrote a blog post in

02:56:12.880 --> 02:56:17.680
response to a person looking for advice about whether with a CS degree to choose a nine to five

02:56:17.680 --> 02:56:24.400
job or to become an entrepreneur. It's an interesting question. If you just think from

02:56:24.400 --> 02:56:30.000
first principles right now, somebody has took a few years in programming, has loved software

02:56:30.000 --> 02:56:37.440
engineering. In some sense, creating Python is an entrepreneurial endeavor. That's a choice that

02:56:37.440 --> 02:56:44.000
a lot of people that are good programmers have to make. Do I work for a big company or do I

02:56:44.000 --> 02:56:51.760
create something new? Or you can work for a big company and create something new there.

02:56:53.200 --> 02:57:00.000
Oh, inside the... Yeah. I mean, big companies have individuals who create new stuff

02:57:00.800 --> 02:57:06.000
that eventually grows big all the time. And if you're the person that creates a new thing

02:57:06.000 --> 02:57:11.040
and grows big, you'll have a chance to move up quickly in the company to run that thing.

02:57:12.320 --> 02:57:19.920
If that's your aspiration, what can also happen is that someone is a brilliant engineer and

02:57:19.920 --> 02:57:30.560
sort of builds a great first version of a product and has no aspirations to then become a manager

02:57:30.560 --> 02:57:36.080
and grow the team from five people to 20 people to a hundred people to a thousand people and

02:57:37.200 --> 02:57:45.520
be in charge of hiring and meetings. And they move on to inventing another crazy thing inside

02:57:45.520 --> 02:57:53.600
the same company or sometimes they found a startup or they moved to a different great

02:57:54.480 --> 02:58:01.520
large or small company. There's all sorts of models. And sometimes people sort of do have this

02:58:02.160 --> 02:58:10.480
whole trajectory from engineer buckling down writing code, not nine to five, but more like

02:58:11.440 --> 02:58:19.280
noon till midnight, seven days a week, and coming up with a product and sort of

02:58:19.760 --> 02:58:27.200
staying in charge. I mean, if you take Drew Houston, Dropbox's founder, he is still the CEO.

02:58:28.720 --> 02:58:35.760
And at least when I was there, he had not checked out or anything. He was good CEO,

02:58:36.400 --> 02:58:43.760
but he had started out as the technical inventor or co-inventor. And so he was someone who,

02:58:43.760 --> 02:58:50.560
if he always aspired that, I think when he was 16, he already started a company. So maybe he did,

02:58:50.560 --> 02:59:02.720
but it turned out that he did have the personal sort of skill set needed to grow and stay on top.

02:59:02.720 --> 02:59:10.000
And other people sort of are brilliant engineers and horrible at management. I count myself

02:59:10.640 --> 02:59:20.480
at least in the second category. So your first love and still your love is to be the quote

02:59:20.480 --> 02:59:29.600
unquote individual contributor to the program. Do you have advice for a programming beginner

02:59:29.600 --> 02:59:39.600
on how to learn Python the right way? Find something you actually want to do

02:59:40.320 --> 02:59:49.680
with it. If you say, I want to learn skill X, that's not enough motivation. You need to pick

02:59:49.680 --> 02:59:57.360
something and it can be a crazy problem you want to solve. It can be completely unrealistic,

02:59:57.360 --> 03:00:09.920
but something that challenges you into actually learning coding in some language.

03:00:11.040 --> 03:00:14.720
And there are so many projects out there you can look for like that. That doesn't have to be some

03:00:14.720 --> 03:00:19.920
big ambitious thing. It could be writing a small bot. If you're into social media, you can write

03:00:19.920 --> 03:00:28.000
a Reddit bot or a Twitter bot or some aspect of automating something that you do every single day,

03:00:28.560 --> 03:00:32.960
processing files, all that kind of stuff. Nowadays, you can take machine learning

03:00:32.960 --> 03:00:40.080
components and sort of plug those things together, do cool stuff with them.

03:00:40.080 --> 03:00:43.360
So that's actually a really good example. So if you're interested in machine learning,

03:00:43.360 --> 03:00:50.160
the state of machine learning is such that a tutorial that takes an hour can get you to

03:00:50.160 --> 03:00:56.080
start using pre-trained models to do something super cool. And that's a good way to learn Python

03:00:56.080 --> 03:01:02.000
because you learn just enough to run this model. And that's a sneaky way to get in there to figure

03:01:02.000 --> 03:01:10.800
out how to import stuff, how to write basic IO, how to run functions. I'm not sure if it's the

03:01:10.800 --> 03:01:15.760
best way to learn the basics in Python, but it could be nice to just get fall in love first

03:01:15.760 --> 03:01:20.560
and then figure out the basics, right? Yeah. You can't expect to learn Python

03:01:21.120 --> 03:01:31.440
from a one hour video. Blanking out on the name of someone who wrote a very funny blog post

03:01:31.440 --> 03:01:39.200
where he said, I see all these ads for things like learn Python in 10 days or so.

03:01:40.160 --> 03:01:44.480
And he said the goal should be learn Python in 10 years.

03:01:45.120 --> 03:01:51.120
That's hilarious, but I completely disagree with that. I think the criticism behind that is that

03:01:52.320 --> 03:01:57.120
the place is just like the blog post from earlier. The places that tell you learn Python

03:01:57.120 --> 03:02:01.840
in five minutes or 10 minutes, they're actually usually really bad tutorials. So the thing is,

03:02:01.920 --> 03:02:10.320
I do believe that you can learn a thing in an hour to get some interesting quick,

03:02:10.320 --> 03:02:15.920
like it hooks you. But it just takes a tremendous amount of skill to be that kind of educator.

03:02:15.920 --> 03:02:20.960
Richard Feynman was able to condense a lot of ideas and physics in a very short amount of time,

03:02:20.960 --> 03:02:28.480
but that takes a deep, deep understanding. And so yes, of course, I think the 10 years is about the

03:02:28.480 --> 03:02:34.880
experience, the pain along the way. Well, you have to practice. You can memorize the syntax,

03:02:37.040 --> 03:02:41.440
well, I couldn't, but maybe someone else can, but that doesn't make you a coder.

03:02:42.160 --> 03:02:49.040
Yeah. Actually, coding has changed in fascinating ways because so much of coding is copying and

03:02:49.040 --> 03:02:54.000
pasting from Stack Overflow and then adjusting, which is another way of coding. And I don't want

03:02:54.000 --> 03:02:58.560
to talk down to that kind of style of coding because it's kind of nicely efficient.

03:02:58.560 --> 03:03:02.480
But do you know where that is going? Code generation?

03:03:03.280 --> 03:03:08.400
No, seriously. Github Copilot. I use it every day and it-

03:03:08.400 --> 03:03:08.960
Really?

03:03:08.960 --> 03:03:15.920
Yeah. It writes a lot of code for me and usually it's slightly wrong, but it still saves me typing

03:03:15.920 --> 03:03:23.040
because all I have to do is like change one word in a line of text that otherwise it generated

03:03:23.040 --> 03:03:29.680
perfectly. And how many times are you looking for like, oh, what was I doing this morning? I

03:03:29.680 --> 03:03:37.840
was looking for a begin marker and I was looking for an end marker. And so begin is blah, blah,

03:03:37.840 --> 03:03:48.320
blah, search for begin. This is the begin token. And then the next line, I type E and it completes

03:03:48.320 --> 03:03:55.680
the whole line with end instead of begin. That's a very simple example. Sometimes if I name my

03:03:55.680 --> 03:04:04.240
function right, it writes a five or 10 line function. And you know Python enough to very

03:04:04.240 --> 03:04:08.960
quickly then detect the issues. So it becomes a really good dance partner then.

03:04:08.960 --> 03:04:15.440
It doesn't save me a lot of thinking, but since I'm a poor typist, I'm very much appreciative of

03:04:16.080 --> 03:04:24.400
all the typing it does for me. Much better actually than the previous generation of suggestions that

03:04:24.400 --> 03:04:33.920
are also still built in VS code where when you hit like a dot, it tries to guess what the type is of

03:04:33.920 --> 03:04:40.000
the variable to the left of the dot. And then it gives you a list, a pop down menu of what the

03:04:40.000 --> 03:04:44.480
attributes of that object are. But Copilot is much, much smoother than that.

03:04:44.480 --> 03:04:50.240
Well, it's fascinating to hear that you use GitHub Copilot. Do you think, do you worry

03:04:50.240 --> 03:04:57.600
about the future of that? Did the automatic code generation, the increasing amount of

03:04:58.320 --> 03:05:04.960
that kind of capability, are programmers jobs threatened or is there still a significant role

03:05:04.960 --> 03:05:09.120
for humans? Are programmers jobs threatened by the existence of stack overflow?

03:05:09.120 --> 03:05:17.920
I don't think so. It helps you take care of the boring stuff and you shouldn't try to use it to

03:05:17.920 --> 03:05:26.000
do something that you have no way of understanding what you're doing yet. A tool like that is always

03:05:26.000 --> 03:05:35.520
best when the question you're asking is, please remind me of how I do this, which I could do.

03:05:35.520 --> 03:05:43.360
I could look up how to do it, but right now I've forgotten whether the method is called foo or bar

03:05:44.000 --> 03:05:52.000
or what the shape of the API is. Does it use a builder object or a constructor or a factory or

03:05:54.320 --> 03:06:01.120
something else? And what are the parameters? It serves that role. It's like a great assistant.

03:06:01.840 --> 03:06:08.800
But the creative work of deciding what you want the code to do is totally yours.

03:06:10.160 --> 03:06:15.680
What do you think is the future of Python in the next 10, 20, 50 years, 100 years? You look forward,

03:06:16.240 --> 03:06:22.080
you ever think about, you ever imagine a future of human civilization for living inside the metaverse

03:06:23.680 --> 03:06:29.120
on Mars, humanoid robots everywhere? What part does Python play in that?

03:06:30.080 --> 03:06:36.640
It'll eventually become sort of a legacy language that plays an important role,

03:06:36.640 --> 03:06:42.160
but that most people have never heard of and don't need to know about, just like

03:06:43.120 --> 03:06:50.720
all kinds of basic structures in biology, like mitochondria.

03:06:51.840 --> 03:06:57.440
So it permeates all of life, all of digital life, but people just build on top of it,

03:06:57.520 --> 03:06:59.520
and they only know the stuff that's on top of it.

03:07:01.040 --> 03:07:03.280
Because you build layers of abstractions. I mean,

03:07:04.000 --> 03:07:10.480
most programmers nowadays rarely need to do binary arithmetic, right?

03:07:13.360 --> 03:07:19.680
Yeah, or even think about it or even learn about it, or they can go quite far without knowing.

03:07:19.680 --> 03:07:27.040
I started building little digital circuits out of NAND gates that I built myself with

03:07:27.040 --> 03:07:35.360
transistors and resistors. So I sort of, I feel very blessed that with that start when I was a

03:07:35.360 --> 03:07:45.520
teenager, I learned some of the basic, at least concepts that go into building a computer,

03:07:46.400 --> 03:07:55.600
and I sort of every part, I have some understanding what it's for and why it's there

03:07:55.600 --> 03:08:03.360
and how it works. And I can't forget about all that most of the time, but I enjoy knowing,

03:08:03.360 --> 03:08:11.600
oh, if you go deeper, at some point you get to NAND gates and half adders and shift registers.

03:08:11.600 --> 03:08:17.520
And when it comes to the point of how do you actually make a chip out of silicon,

03:08:17.520 --> 03:08:23.040
I have no idea. That's just magic to me. But you enjoy knowing that you can walk a

03:08:23.040 --> 03:08:28.160
while towards the lower and lower layers, but you don't need to. It's nice.

03:08:28.160 --> 03:08:35.360
The other day as a sort of a mental exercise, I was trying to figure out if I could build

03:08:39.440 --> 03:08:49.200
flip-flop circuits out of relays. I was just sort of trying to remember, oh, how does a relay work?

03:08:49.200 --> 03:08:54.720
Yeah, there's this electromagnetic force that pulls a switch open or shut,

03:08:56.800 --> 03:09:07.040
and you can open one switch and shut another. You can have multiple contacts that go at once,

03:09:07.040 --> 03:09:13.680
and how many relays do I really need to represent one bit of information? Can the relay just feed

03:09:13.680 --> 03:09:19.360
on itself? I don't think I got to the final solution, but it was fun that I

03:09:21.360 --> 03:09:25.920
could still do a little bit of problem solving and thinking at that level.

03:09:26.800 --> 03:09:30.560
And it's cool how we build on top of each other. So there's people that are just,

03:09:31.680 --> 03:09:35.600
you stood on the shoulders of giants and there's others who'll stand on your shoulders, and it's

03:09:36.160 --> 03:09:40.800
a giant, beautiful hierarchy. Yeah, I feel I sort of covered this

03:09:40.800 --> 03:09:46.320
middle layer of the technology stack where it sort of peters out below the

03:09:47.840 --> 03:09:56.000
level of NAND gates, and at the top, I sort of lose track when it gets to machine learning.

03:09:56.800 --> 03:10:01.200
And then eventually the machine learning will build higher and higher layers that will help

03:10:01.200 --> 03:10:07.200
us understand the lowest layer of the physics, and thereby the universe figures out how

03:10:08.160 --> 03:10:17.680
it itself works. Maybe, maybe not. Yeah, I mean, it's possible. If you think of human consciousness,

03:10:17.680 --> 03:10:27.840
if that's even the right concept, it's interesting that we have this super parallel brain that does

03:10:27.840 --> 03:10:34.560
all these incredible parallel operations like image recognition. I recognize your face.

03:10:35.520 --> 03:10:41.440
There's a huge amount of processing that goes on in parallel. There's lots of nerves between my

03:10:41.440 --> 03:10:46.960
eyes and my brain, and the brain does a whole bunch of stuff all at once because it's actually

03:10:46.960 --> 03:10:53.680
really slow circuits, but there are many of them that all work together. On the other hand,

03:10:53.680 --> 03:11:01.120
when I'm speaking, everything is completely sequential. I have to sort of string words

03:11:01.200 --> 03:11:08.720
together one at a time, and when I'm thinking about stuff, when I'm understanding the world,

03:11:09.840 --> 03:11:13.520
I'm also thinking of everything one step at a time.

03:11:15.440 --> 03:11:24.640
And so we've got all this incredible parallel circuitry in our brains, and eventually we use

03:11:24.640 --> 03:11:32.000
that to simulate a single threaded, much, much higher level interpreter.

03:11:34.480 --> 03:11:39.120
It's exactly. I mean, that's the illusion of it. That's the illusion of it for us,

03:11:39.120 --> 03:11:45.120
that it's a single sequential set of thoughts, and all of that came from a single cell

03:11:45.120 --> 03:11:53.040
through the process of embryogenesis. So DNA is the code. DNA holds the entirety of the code,

03:11:53.040 --> 03:11:58.400
the information, and how to use that information to build up an organism, the entire like

03:11:59.840 --> 03:12:06.800
the arms, the legs, the brain. So you don't buy a computer, you buy like a.

03:12:06.800 --> 03:12:09.920
You buy a seed, a diagram.

03:12:09.920 --> 03:12:14.720
And then you plant the computer, and it builds itself in almost the same way,

03:12:15.440 --> 03:12:24.160
and then does the computation, and then eventually dies. It gets stale, but gives birth to young

03:12:24.160 --> 03:12:29.680
computers more and more, and gives them lessons, but they figure stuff out on their own, and over

03:12:29.680 --> 03:12:35.760
time it goes on that way. And those computers, when they go to college, try to figure out how

03:12:35.760 --> 03:12:40.560
to program, and they built their own little computers. They're increasingly more intelligent,

03:12:40.560 --> 03:12:43.920
increasingly higher and higher levels of abstractions.

03:12:43.920 --> 03:12:51.280
Isn't it interesting that you see the same thing appearing at different levels though,

03:12:51.280 --> 03:13:02.320
because you have cells that create new cells, and eventually that builds a whole organism,

03:13:02.320 --> 03:13:09.920
but then the animal, or the plant, or the human has its own mechanism of replication.

03:13:11.360 --> 03:13:19.440
That is sort of connected in a very complicated way to the mechanism of replication of the cells.

03:13:19.440 --> 03:13:26.560
And then if you look inside the cell, if you see how DNA and proteins are connected,

03:13:26.560 --> 03:13:33.200
then there is yet another completely different mechanism whereby proteins are mass produced

03:13:33.440 --> 03:13:42.480
using enzymes and a little bit of code from DNA. And of course, viruses break into it at that level.

03:13:42.480 --> 03:13:49.200
And while the mechanisms might be different, it seems like the nature of the mechanism

03:13:49.200 --> 03:13:57.360
is the same, and it carries across natural languages, and programming languages, humans,

03:13:57.440 --> 03:14:04.000
humans, maybe even human civilizations or intelligent civilizations, and then all the

03:14:04.000 --> 03:14:10.720
way down to the single cell organism. It is fascinating to see what abstraction

03:14:10.720 --> 03:14:18.160
levels are built on top of individual humans, and how you have whole societies

03:14:19.760 --> 03:14:26.960
that have a similar self-preservation, I don't know what it is, instinct,

03:14:27.440 --> 03:14:33.520
nature, abstraction, as the individuals have and the cells have.

03:14:33.520 --> 03:14:38.720
And they self-replicate and breed in different ways. It is hard for us humans to introspect it,

03:14:38.720 --> 03:14:44.880
because we are very focused on our particular layer of abstraction. But from an alien perspective,

03:14:44.880 --> 03:14:51.440
looking on Earth, they will probably see the higher level organism of human civilization

03:14:52.560 --> 03:14:56.960
as part of this bigger organism of life on Earth itself. In fact, that could be an organism,

03:14:56.960 --> 03:15:05.440
just alone, just life, life, life on Earth. This has been a wild, both philosophical and technical

03:15:05.440 --> 03:15:11.920
conversation, Guido. You're an amazing human being. You were gracious enough to talk to me when I was

03:15:11.920 --> 03:15:17.600
first doing this podcast, and one of the earliest first people I've talked to, somebody I admired

03:15:17.600 --> 03:15:21.440
for a long time. It's just a huge honor that you did it at that time, and you do it again.

03:15:21.440 --> 03:15:22.800
You're awesome. Thank you, Lex.

03:15:23.760 --> 03:15:28.480
Thanks for listening to this conversation with Guido Menrossum. To support this podcast,

03:15:28.480 --> 03:15:33.280
please check out our sponsors in the description. And now, let me leave you with some words from

03:15:33.280 --> 03:15:38.160
Oscar Wilde. Experience is the name that everyone gives to their mistakes.

03:15:38.880 --> 03:15:42.160
Thank you for listening, and hope to see you next time.

